--
-- Binding between FlowDiagram concept and SFC
-- 
-- Notes:
-- 		This binding is complex, but writing a transformation for this XSD-based meta-model
--		would have been a lot more, because it would have mixed both concerns: dealing with
--      a degenerated meta-model and transforming to petri-nets. In some way, this binding
--      is just fixing the meta-model.
binding SFC for FD { 
	class FlowDiagram to SFCType1	
	class Node        to StepType, TransitionType1, -- Important to add here every "virtual subclass"
	                     SelectionDivergenceType, SelectionConvergenceType, 
	                     SimultaneousDivergenceType, SimultaneousConvergenceType 
	
	-- Edges are not transitions (which has a different semantics), 
	-- but Connection/ConnectionPointIn which is an structural concept to link "SFC nodes" 
	-- (which include transitions)
	-- class FlowEdge    to TransitionType
	class FlowEdge to Connection
	
	class Task        to StepType, TransitionType1 
		     						           
	class ExclusiveChoice to SelectionDivergenceType
	-- HOW TO MAP THE SELECTION CONVERGENCE TYPE? -> Not sure about the semantics
	class SimpleMerge     to SelectionConvergenceType
	                                        
	class ParallelSplit     to SimultaneousDivergenceType
	class Synchronization   to SimultaneousConvergenceType

	class MultiChoice     to NONE	
	
	feature FlowDiagram.nodes = self.allNodes
	-- 
	feature FlowDiagram.edges = self.transition	

	feature FlowEdge."in" = FD!SFCType1.allInstances()->first().allNodes->any(n | n.localId = self.refLocalId) 
	feature FlowEdge.out  = self.parent

	--
	-- feature Node."in" = FD!Connection.allInstances()->select(c | c.parent = self )
	--
	
	feature Node[StepType]."in" = self.connectionPointIn.connection 
	feature Node[StepType].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)

	feature Node[TransitionType1]."in" = self.connectionPointIn.connection 
	feature Node[TransitionType1].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)

	feature Node[SelectionDivergenceType]."in" = self.connectionPointIn.connection 
	feature Node[SelectionDivergenceType].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)

	feature Node[SelectionConvergenceType]."in" = self.connectionPointIn.connection 
	feature Node[SelectionConvergenceType].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)

	feature Node[SimultaneousDivergenceType]."in" = self.connectionPointIn.connection 
	feature Node[SimultaneousDivergenceType].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)

	feature Node[SimultaneousConvergenceType]."in" = self.connectionPointIn.connection 
	feature Node[SimultaneousConvergenceType].out  = FD!Connection.allInstances()->select(c | c.refLocalId = self.localId)


	-- I forgot to use [ ] to qualify the isInitial/final
	feature Task[StepType].isInitial = self.initialStep
	feature Task[TransitionType1].isInitial   = false   	

	feature Task[StepType].isFinal   = false   	
	feature Task[TransitionType1].isFinal   = false   	

	feature Task[TransitionType1].name = 'transition' 
	

	helper Connection.parent : OclAny = self.refImmediateComposite().refImmediateComposite()
	
	helper SFCType1.allNodes : OclAny = self.step.
									 union(self.transition).
	                                 union(self.selectionDivergence).
	                                 union(self.selectionConvergence).
	                                 union(self.simultaneousDivergence).
	                                 union(self.simultaneousConvergence)	                                 
}


