-- @path BPMN=/genericity.atl.transformations/examples/flow_diagrams/bpmn.concrete/bpmn.ecore
-- @path PN=/genericity.atl.transformations/examples/flow_diagrams/metamodels/petri_nets.ecore

module intalio2pn;
create OUT : PN from IN : BPMN;

helper context BPMN!Activity def: toPlaceAsInput : Boolean = 
	self.activityType = #Task or
	self.activityType = #EventStartEmpty or
	self.activityType = #EventEndEmpty or
	self.activityType = #EventEndTerminate or
	self.activityType = #GatewayDataBasedExclusive or
	self.activityType = #GatewayEventBasedExclusive or
	self.activityType = #GatewayDataBasedInclusive;
helper context BPMN!Activity def: toPlaceAsOutput : Boolean = 
	self.activityType = #Task or
	self.activityType = #EventStartEmpty or
	self.activityType = #EventEndEmpty or
	self.activityType = #EventEndTerminate or
	self.activityType = #GatewayDataBasedExclusive or
	self.activityType = #GatewayEventBasedExclusive;
helper context BPMN!Activity def: toTransitionAsInput : Boolean = 
	self.activityType = #GatewayParallel;
helper context BPMN!Activity def: toTransitionAsOutput : Boolean = 
	self.activityType = #GatewayParallel or
	self.activityType = #GatewayDataBasedInclusive;

helper context Integer def: pow (m:Integer) : Integer = if (m>1) then self*self.pow(m-1) else self endif; -- n^m
helper context Integer def: toSequence ()   : Sequence(Integer) = if self<=0 then Sequence{} else Sequence{self}.union((self-1).toSequence()) endif; -- Sequence{1, 2..., n}
helper context Integer def: choices () : Sequence(Sequence(Boolean)) = 
	if self>1 then 
	    (self-1).choices()->collect(n | n->append(true)) ->union(
		(self-1).choices()->collect(n | n->append(false)))
	else
		Sequence{Sequence{true},Sequence{false}}
    endif;

    
helper context BPMN!Activity def: nodeGenerator : Sequence(TupleType(source : BPMN!Vertex, num : Integer)) =
	(2.pow(self.outgoingEdges->size())-1).toSequence()->iterate(n; result: Sequence(TupleType(source : BPMN!Vertex, num : Integer)) = Sequence { } |
		let tuple : OclAny = Tuple { source : BPMN!Vertex = self, num : Integer = n } in	
			result.including(tuple)		
	);    
    
rule create_transition(source : BPMN!Vertex, num : Integer) {
	using { choices : Sequence(Boolean) = source.outgoingEdges->size().choices()->at(num); }
 	to  transition : PN!Transition (
-- 		name <- 'transition ' + num,
		in   <- source,
        out  <- source.outgoingEdges->size().toSequence()->iterate (i; result:Sequence(BPMN!Vertex)=Sequence{} | 
		            if choices->at(i)=true then
		                result->append( 
		       	         if source.outgoingEdges->at(i).target.toPlaceAsInput
				         then source.outgoingEdges.at(i).target
				         else source.outgoingEdges.at(i)
				         endif
		       	         )
		            else
		              result
		            endif
			         ) 				
 	) do {
 		-- This is important, it is the result value...
 		transition;
 	}
}
	
-- BUILDING BLOCKS ---------------------------------------------------------------------------------------------

-- the bpmn diagram is transformed into a Petri net 
rule diagram {
	from bpmn : BPMN!BpmnDiagram 
	to   net  : PN!PetriNet (
		elems <- -- activitirs and edges
		         bpmn.pools->collect(pool | pool.vertices->select(vertex | vertex.oclIsKindOf(BPMN!Activity))).append(
			     bpmn.pools->collect(pool | pool.sequenceEdges)).append(
			     -- inclusive gateways
				 bpmn.pools->collect(pool | pool.vertices->select(vertex | vertex.oclIsKindOf(BPMN!Activity) and vertex.activityType = #GatewayDataBasedInclusive))->flatten()
				 	 	->collect(n | n.nodeGenerator)->flatten()->collect(n | thisModule.create_transition(n.source, n.num)) )
	)
}

-- the start event is transformed into a place with 1 token
rule startEvent {
	from activity : BPMN!Activity (activity.activityType = #EventStartEmpty)
	to   place    : PN!Place (
		name <- 'Initial',
		tokens <- 1
		)	
}

-- each task is transformed into a place without tokens
rule task { 
	from activity : BPMN!Activity (activity.activityType = #Task) 
 	to   place : PN!Place (
		name   <- activity.name,
		tokens <- 0
 	    )
}

-- each final event is transformed into a place without tokens
rule finalEvent { 
	from activity  : BPMN!Activity (activity.activityType = #EventEndEmpty or activity.activityType = #EventEndTerminate) 
 	to   place : PN!Place (
		name <- 'Final', 
		tokens <- 0
 	    )
}

-- each parallel gateway is transformed into a transition
rule parallel_gateway {
	from activity    : BPMN!Activity (activity.activityType = #GatewayParallel)
    to   transition  : PN!Transition (
		name <- 'Parallel Gateway',		
		-- connect to input places
		in <- activity.incomingEdges->select(edge | edge.source.oclIsKindOf(BPMN!Activity) and
			                                       (edge.source.activityType = #Task or 
			                                       	edge.source.activityType = #EventStartEmpty or
			                                       	edge.source.activityType = #EventEndEmpty or 
			                                       	edge.source.activityType = #EventEndTerminate or 
													edge.source.activityType = #GatewayDataBasedExclusive or 
													edge.source.activityType = #GatewayEventBasedExclusive)
													)->collect(edge | edge.source)
		-- connect to input transitions
			->union(
			  activity.incomingEdges->select(edge |  edge.source.oclIsKindOf(BPMN!Activity) and
			                                       (edge.source.activityType = #GatewayParallel or 
			                                       	edge.source.activityType = #GatewayDataBasedInclusive)
			  	                                    )
			 ),
		-- connect to output places 	 
		out <- activity.outgoingEdges->select(edge | edge.target.oclIsKindOf(BPMN!Activity) and
			                                       (edge.target.activityType = #Task or 
			                                       	edge.source.activityType = #EventStartEmpty or
			                                       	edge.target.activityType = #EventEndEmpty or 
			                                       	edge.target.activityType = #EventEndTerminate or 
													edge.target.activityType = #GatewayDataBasedExclusive or 
													edge.target.activityType = #GatewayEventBasedExclusive or
													edge.target.activityType = #GatewayDataBasedInclusive
													)
													)->collect(edge | edge.target)
		-- connect to output transitions 	 
			->union(
			  activity.outgoingEdges->select(edge | edge.target.oclIsKindOf(BPMN!Activity) and
			                                        edge.target.activityType = #GatewayParallel
			  	                                    )
			 )
		) 		
}

-- each exclusive gateway is transformed into a place
rule exclusive_gateway {
	from activity  : BPMN!Activity (activity.activityType = #GatewayDataBasedExclusive or activity.activityType = #GatewayEventBasedExclusive) 
	to   place  : PN!Place (
		name   <- 'Exclusive Gateway',
		tokens <- 0
		)
}

-- each inclusive gateway is transformed into a place connected to (2^n)-1 transitions;
-- the transition is created by rule create_transition, invoked from rule diagram
rule inclusive_gateway {
	from activity : BPMN!Activity (activity.activityType = #GatewayDataBasedInclusive)
	to 	 place : PN!Place (
		name <- 'Inclusive Gateway',
		tokens <- 0
	)
}

-- INTERCONNECTIONS --------------------------------------------------------------------------------------------

-- edges connecting activities that are transformed into places, are transformed into transitions
rule place_place {
	from edge        : BPMN!SequenceEdge ( edge.source.toPlaceAsOutput and edge.target.toPlaceAsInput )
	to   transition  : PN!Transition (
	    in  <- edge.source,
		out <- edge.target
		)
}

-- edges connecting activities that are transformed into transitions, are transformed into places
rule transition_transition {
	from edge  : BPMN!SequenceEdge ( edge.source.toTransitionAsOutput and edge.target.toTransitionAsInput ) 
	to   place : PN!Place (
		--name   <- edge.source.activityType + '-' + edge.target.activityType,
		tokens <- 0
		)
}
