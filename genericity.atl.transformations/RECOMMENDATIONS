
Lessons learned about how to write a generic transformation (recommendations)
  * Instead of "self" to denote a supertype's instance (e.g. Label) 
    use a helper to make substitution easier: self => self_label
  
  * Don't use "container" to get the container, because this is an implicit
    dependency with the metamodel, use a helper
  
  * Having multiple inheritance becomes a problem both in the concept and
    the actual models, because it means that a class has two roles.
    Here are two examples (from basicblocks example):
    
      - Multiple inheritance in the concept:
      
        In the concept goto.target refers to label, which is in
        turn an statement. The transformation is supposed to work
        because "statement2basicblock" rule get the basic block
        for an statement. 
     
        rule goto_statement2edge {			
          from goto : Imp!Goto 
          to edge : BBL!DirectedEdge (
             target <- goto.target 		
          )
        } 

        rule statement2basicblock {			
	       from stm : Imp!Statement ( ... ) 
		   to   bbl : BBL!BasicBlock 
	    )
	    
	    However, in the actual metamodel target refers to just a Label
	    which is contained in the statement of interest, so there are
	    no rule than can resolve the BasicBlock for the label.
	    
	    The solution is a bit dependent on the language. If a "propagation"
	    mechanism would be available a rule matching labels and returning
	    basic blocks could make the adaptation.
	    
	    In the case of ATL "goto.target" has to be changed by 
	    "goto.target_statement", to allow redefinition.
	    
      - Multiple inheritance in the actual metamodel.

  * Another problem is when the concept covers elements not found in the 
    actual metamodel.  For instance, BasicBlocks has conditional and
    unconditional gotos, but NQC only has unconditional gotos.
    ¿How to remove dependencies with those parts? ¿Dummy elements in the 
    actual metamodel?
    The problem may appear in: from parts and oclIsKindOf
    
    	if you have,
    		
    		if expr.oclIsKindOf(ProblematicMetaclass)
    		   xxx
    		else
    		
    		endif
    		  
        you could safely remove the if part and take the else part only.

  * The same concept element needs to be bound more than once. This typically
    happen when the actual metamodel has modeled two variants of the same
    concepts without introducing a superclass. For example: subroutine and function,
    without proper superclass to be mapped to Procedure. 
    
--
-- Issues:
-- * Possibility of removing bindings for those features that are 
--   in the target concept but not actual target.


== Using a plain m2m to adapt instead of our approach?

There are several differences:

i) Performance, in particular with big models
ii) Backwards traceability would be needed
iii) Generic transformations are a "reuse as you go" approach,
     which should little effort on the behalf of the user
     (the developer is in charge of providing a set of reusable concepts)  

