-- @atlcompiler	atl2006
-- @name			UML22Measure
-- @version		1.1
-- @domains		UML2, measurement data, metrics
-- @authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
-- @date			2007/08/02
-- @description	This transformation is used to collect measurement data on a UML2 model, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
-- @see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.
module UML22Measure;
create OUT : Measure from IN : MDEPTH;

-- @begin attribute helpers measureLevel
-- @comments Defines the measure level among {#package,#class}. 
-- @comments The package level allows measures on packages.
-- @comments The class level allows measures on packages and classes.
helper def: measureLevel : Measure!ElementKind =
 #class; -- @end attribute helper measureLevel
-- @begin attribute helper root
-- @comments The root measure set.
-- @end attribute helper measureLevel
-- @begin attribute helper root
-- @comments The root measure set.
helper def: root : Measure!RootMeasureSet =
 OclUndefined; -- @end attribute helper root
-- @begin attribute helper MetricByName
-- @comments The map of metrics by name.
-- @end attribute helper root
-- @begin attribute helper MetricByName
-- @comments The map of metrics by name.
helper def: MetricByName : Map(String, Measure!Metric) =
 Map {}; -- @end attribute helper MetricByName
-- @begin helper defaultName
-- @comments Returns the name of the named element or "Anonymous".
-- @end helper defaultName
-- @begin entrypoint rule Metrics
-- @comments Registers the MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
 to
  root : Measure!RootMeasureSet (
   modelType <- #UML2
  )
 do {
  thisModule.root <- root;
  if(thisModule.measureLevel = #package or thisModule.measureLevel = #class) {
   -- ==================================================
   -- MOOD Metrics : Intra-Specification Level Metrics =
   -- ==================================================
   -- ==================================================
   -- MOOD Metrics : Intra-Specification Level Metrics =
   -- ==================================================
   -- ==================================================
   -- MOOD Metrics : Intra-Specification Level Metrics =
   -- ==================================================
   root.categories <- thisModule.Category('MOOD', 'Metrics for Object-Oriented' + ' Design');
   thisModule.Metric('MOOD', 'AIF', 'Attributes Inheritance Factor');
   thisModule.Metric('MOOD', 'OIF', 'Operations Inheritance Factor');
   thisModule.Metric('MOOD', 'AHF', 'Attributes Hiding Factor');
   thisModule.Metric('MOOD', 'OHF', 'Operations Hiding Factor');
   thisModule.Metric('MOOD', 'BPF', 'Behavioral Polymorphism Factor');
   thisModule.Metric('MOOD', 'CCF', 'Class Coupling Factor');
   thisModule.Metric('MOOD', 'ICF', 'Internal Coupling Factor'); -- ===================================================
   -- MOOD2 Metrics : Intra-Specification Level Metrics =
   -- ===================================================
   -- ===================================================
   -- MOOD2 Metrics : Intra-Specification Level Metrics =
   -- ===================================================
   -- ===================================================
   -- MOOD2 Metrics : Intra-Specification Level Metrics =
   -- ===================================================
   -- ===================================================
   -- MOOD2 Metrics : Intra-Specification Level Metrics =
   -- ===================================================
   root.categories <- thisModule.Category('MOOD2', 'Metrics for Object-Oriented' + ' Design 2');
   thisModule.Metric('MOOD2', 'IIF', 'Internal Inheritance Factor');
   thisModule.Metric('MOOD2', 'AHEF', 'Attributes Hiding Effectiveness Factor');
   thisModule.Metric('MOOD2', 'OHEF', 'Operations Hiding Effectiveness Factor');
  }
  if(thisModule.measureLevel = #class) {
   -- ===============
   -- MOOSE Metrics =
   -- ===============
   -- ===============
   -- MOOSE Metrics =
   -- ===============
   -- ===============
   -- MOOSE Metrics =
   -- ===============
   root.categories <- thisModule.Category('MOOSE', 'Metrics for Object-Oriented' + ' Software Engineering');
   thisModule.Metric('MOOSE', 'DIT', 'Depth of Inheritance Tree');
   thisModule.Metric('MOOSE', 'NOC', 'Number of Children');
   thisModule.Metric('MOOSE', 'CBO', 'Coupling Between Objects');
   thisModule.Metric('MOOSE', 'RFC', 'Response for a Class'); -- ================
   -- EMOOSE Metrics =
   -- ================
   -- ================
   -- EMOOSE Metrics =
   -- ================
   -- ================
   -- EMOOSE Metrics =
   -- ================
   -- ================
   -- EMOOSE Metrics =
   -- ================
   root.categories <- thisModule.Category('EMOOSE', 'Extended MOOSE');
   thisModule.Metric('EMOOSE', 'SIZE2', 'Number of local Attributes ' + 'and' + ' Operations defined in the Class');
  }
  if(thisModule.measureLevel = #package or thisModule.measureLevel = #class) {
   -- ===============
   -- QMOOD Metrics =
   -- ===============
   -- ===============
   -- QMOOD Metrics =
   -- ===============
   -- ===============
   -- QMOOD Metrics =
   -- ===============
   root.categories <- thisModule.Category('QMOOD', 'Quality Model for' + ' Object-Oriented Design');
   thisModule.Metric('QMOOD', 'DSC', 'Design Size in Classes');
   thisModule.Metric('QMOOD', 'NOH', 'Number of Hierarchies');
   thisModule.Metric('QMOOD', 'NIC', 'Number of Independent Classes');
   thisModule.Metric('QMOOD', 'NSI', 'Number of Single Inheritance');
   thisModule.Metric('QMOOD', 'NNC', 'Number of Internal Classes');
   thisModule.Metric('QMOOD', 'NAC', 'Number of Abstract Classes');
   thisModule.Metric('QMOOD', 'NLC', 'Number of Leaf Classes');
   thisModule.Metric('QMOOD', 'ADI', 'Average Depth of Inheritance');
   thisModule.Metric('QMOOD', 'AWI', 'Average Width of Inheritance');
   thisModule.Metric('QMOOD', 'ANA', 'Average Number of Ancestors');
  }
  if(thisModule.measureLevel = #class) {
   thisModule.Metric('QMOOD', 'MFA', 'Measure of Functional Abstraction');
   thisModule.Metric('QMOOD', 'MAA', 'Measure of Attribute Abstraction');
   thisModule.Metric('QMOOD', 'MAT', 'Measure of Abstraction');
   thisModule.Metric('QMOOD', 'MOA', 'Measure of Aggregation');
   thisModule.Metric('QMOOD', 'MRM', 'Modeled Relationship Measure');
   thisModule.MetricWithPreferredValue('QMOOD', 'DAM', 'Data Access Metric', '>75');
   thisModule.MetricWithPreferredValue('QMOOD', 'OAM', 'Operation Access' + ' Metric', '>75');
   thisModule.MetricWithPreferredValue('QMOOD', 'MAM', 'Member Access Metric', '>75');
   thisModule.Metric('QMOOD', 'NOA', 'Number of Ancestors');
   thisModule.Metric('QMOOD', 'NOM', 'Number of Methods');
   thisModule.Metric('QMOOD', 'CIS', 'Class Interface Size');
   thisModule.Metric('QMOOD', 'NPT', 'Number of Unique Parameter Types');
   thisModule.Metric('QMOOD', 'NPM', 'Number of Parameters per Method');
   thisModule.Metric('QMOOD', 'NOD', 'Number of Attributes');
   thisModule.Metric('QMOOD', 'NAD', 'Number of Abstract Data Types');
   thisModule.Metric('QMOOD', 'NPA', 'Number of Public Attributes');
   thisModule.Metric('QMOOD', 'CSM', 'Class Size Metric');
   thisModule.Metric('QMOOD', 'CAM', 'Cohesion Among Methods of Class');
   thisModule.Metric('QMOOD', 'DCC', 'Direct Class Coupling');
   thisModule.Metric('QMOOD', 'MCC', 'Maximum Class Coupling');
   thisModule.Metric('QMOOD', 'DAC', 'Direct Attribute Based Coupling');
   thisModule.Metric('QMOOD', 'DPC', 'Direct Parameter Based Coupling');
   thisModule.Metric('QMOOD', 'MPC', 'Maximum Parameter Based Coupling');
   thisModule.Metric('QMOOD', 'CCD', 'Class Complexity Based on Data');
   thisModule.Metric('QMOOD', 'CCP', 'Class Complexity Based on Method' + ' Parameters');
   thisModule.Metric('QMOOD', 'CCM', 'Class Complexity Based on Members');
  }
 }
} -- @end entrypoint rule Metrics
-- @begin  rule Package2MeasureSet
-- @comments Collects measurement data on the model (default package) or a package (measureLevel must be set to #package or #class).
-- @end rule Package2MeasureSet
-- @begin lazy rule Class2MeasureSet
-- @comments Collects measurement data on a class (measureLevel must be set to #class).
lazy rule Class2MeasureSet {
 from
  ne : MDEPTH!NodeType
  (
   ne.oclIsTypeOf(MDEPTH!NodeType) and thisModule.measureLevel = #class
  )
 to
  ms : Measure!MeasureSet (
   elementName <- ne.defaultName().debug('Processing metrics on class'),
   elementType <- #class,
   subsets <- ne.nestedClassifier
  )
 do {
  -- ===============
  -- MOOSE Metrics =
  -- ===============
  -- ===============
  -- MOOSE Metrics =
  -- ===============
  -- ===============
  -- MOOSE Metrics =
  -- ===============
  ms.measures <- thisModule.IntegerMeasure('DIT', ne.DIT());
  ms.measures <- thisModule.IntegerMeasure('NOC', ne.NOC());
  ms.measures <- thisModule.IntegerMeasure('CBO', ne.CBO());
  ms.measures <- thisModule.IntegerMeasure('RFC', ne.RFC()); -- ================
  -- EMOOSE Metrics =
  -- ================
  -- ================
  -- EMOOSE Metrics =
  -- ================
  -- ================
  -- EMOOSE Metrics =
  -- ================
  -- ================
  -- EMOOSE Metrics =
  -- ================
  ms.measures <- thisModule.IntegerMeasure('SIZE2', ne.SIZE2()); -- ===============
  -- QMOOD Metrics =
  -- ===============
  -- ===============
  -- QMOOD Metrics =
  -- ===============
  -- ===============
  -- QMOOD Metrics =
  -- ===============
  -- ===============
  -- QMOOD Metrics =
  -- ===============
  ms.measures <- thisModule.PercentageMeasure('MFA', ne.MFA());
  ms.measures <- thisModule.PercentageMeasure('MAA', ne.MAA());
  ms.measures <- thisModule.PercentageMeasure('MAT', ne.MAT());
  ms.measures <- thisModule.IntegerMeasure('MOA', ne.MOA());
  ms.measures <- thisModule.IntegerMeasure('MRM', ne.MRM());
  ms.measures <- thisModule.PercentageMeasure('DAM', ne.DAM());
  ms.measures <- thisModule.PercentageMeasure('OAM', ne.OAM());
  ms.measures <- thisModule.PercentageMeasure('MAM', ne.MAM());
  ms.measures <- thisModule.IntegerMeasure('NOA', ne.NOA());
  ms.measures <- thisModule.IntegerMeasure('NOM', ne.NOM());
  ms.measures <- thisModule.IntegerMeasure('CIS', ne.CIS());
  ms.measures <- thisModule.IntegerMeasure('NPT', ne.NPT());
  ms.measures <- thisModule.DoubleMeasure('NPM', ne.NPM());
  ms.measures <- thisModule.IntegerMeasure('NOD', ne.NOD());
  ms.measures <- thisModule.IntegerMeasure('NAD', ne.NAD());
  ms.measures <- thisModule.IntegerMeasure('NPA', ne.NPA());
  ms.measures <- thisModule.IntegerMeasure('CSM', ne.CSM());
  ms.measures <- thisModule.DoubleMeasure('CAM', ne.CAM());
  ms.measures <- thisModule.IntegerMeasure('DCC', ne.DCC());
  ms.measures <- thisModule.IntegerMeasure('MCC', ne.MCC());
  ms.measures <- thisModule.IntegerMeasure('DAC', ne.DAC());
  ms.measures <- thisModule.IntegerMeasure('DPC', ne.DPC());
  ms.measures <- thisModule.IntegerMeasure('MPC', ne.MPC());
  ms.measures <- thisModule.IntegerMeasure('CCD', ne.CCD());
  ms.measures <- thisModule.IntegerMeasure('CCP', ne.CCP());
  ms.measures <- thisModule.IntegerMeasure('CCM', ne.CCM());
 }
} -- @end lazy rule Class2MeasureSet
-- @begin called rule Category
-- @comments Creates a category for metric classification with a name and a description.
-- @end lazy rule Class2MeasureSet
-- @begin called rule Category
-- @comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
 to
  cat : Measure!Category (
   name <- name,
   desc <- desc
  )
 do {
  cat;
 }
} -- @end called rule Category
-- @begin called rule Metric
-- @comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
-- @end called rule Category
-- @begin called rule Metric
-- @comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
 to
  metric : Measure!Metric (
   name <- name,
   desc <- desc,
   preferredValue <- '!=0',
   category <- thisModule.root.categories->select(cat |
    cat.name = catName
   )->first()
  )
 do {
  thisModule.MetricByName <- thisModule.MetricByName.including(metric.name, metric);
 }
} -- @end called rule Metric
-- @begin called rule MetricWithPreferredValue
-- @comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
-- @end called rule Metric
-- @begin called rule MetricWithPreferredValue
-- @comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
 to
  metric : Measure!Metric (
   name <- name,
   desc <- desc,
   preferredValue <- preferredValue,
   category <- thisModule.root.categories->select(cat |
    cat.name = catName
   )->first()
  )
 do {
  thisModule.MetricByName <- thisModule.MetricByName.including(metric.name, metric);
 }
} -- @end called rule MetricWithPreferredValue
-- @begin called rule IntegerMeasure
-- @comments Stores an Integer measure for the metric which name and value are given.
-- @end called rule MetricWithPreferredValue
-- @begin called rule IntegerMeasure
-- @comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
 to
  meas : Measure!IntegerMeasure (
   metric <- thisModule.MetricByName.get(name),
   value <- value
  )
 do {
  meas;
 }
} -- @end called rule IntegerMeasure
-- @begin called rule DoubleMeasure
-- @comments Stores a Double measure for the metric which name and value are given.
-- @end called rule IntegerMeasure
-- @begin called rule DoubleMeasure
-- @comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
 to
  meas : Measure!DoubleMeasure (
   metric <- thisModule.MetricByName.get(name),
   value <- value
  )
 do {
  meas;
 }
} -- @end called rule DoubleMeasure
-- @begin called rule PercentageMeasure
-- @comments Stores a Percentage measure for the metric which name and value are given.
-- @end called rule DoubleMeasure
-- @begin called rule PercentageMeasure
-- @comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
 to
  meas : Measure!PercentageMeasure (
   metric <- thisModule.MetricByName.get(name),
   value <- value
  )
 do {
  meas;
 }
} -- @end called rule PercentageMeasure
--******************************************************************************************************
--******************************************************************************************************
--uses EMOOSE4UML2;
--******************************************************************************************************
--******************************************************************************************************
-- ===============
-- MOOSE Metrics =
-- ===============
-- @begin helper MOOSE::DIT
-- @comments Depth of Inheritance Tree
-- @comments The length of the longest path of inheritance from the current Class to the root of the tree.
-- @end called rule PercentageMeasure
--******************************************************************************************************
--******************************************************************************************************
--uses EMOOSE4UML2;
--******************************************************************************************************
--******************************************************************************************************
-- ===============
-- MOOSE Metrics =
-- ===============
-- @begin helper MOOSE::DIT
-- @comments Depth of Inheritance Tree
-- @comments The length of the longest path of inheritance from the current Class to the root of the tree.
helper context MDEPTH!NodeType def: DIT() : Integer =
 if self.isRoot then
  0
 else
  if self.PARN() = 1 then
   1
  else
   0
  endif + self.parents->iterate(c; acc : Integer = 0 |
   acc + c.DIT()
  )
 endif; -- @end helper MOOSE::DIT
-- @begin helper MOOSE::NOC
-- @comments Number of Children
-- @comments The number of classes that inherit directly from the current Class.
-- @end helper MOOSE::DIT
-- @begin helper MOOSE::NOC
-- @comments Number of Children
-- @comments The number of classes that inherit directly from the current Class.
helper context MDEPTH!NodeType def: NOC() : Integer =
 self.CHIN(); -- @end helper MOOSE::NOC
-- @begin helper MOOSE::CBO
-- @comments Coupling Between Objects
-- @comments The number of other Classes that are coupled to the current one. Two Classes are coupled when methods declared in one Class use Methods or instance variables defined by the other Class.
-- @end helper MOOSE::NOC
-- @begin helper MOOSE::CBO
-- @comments Coupling Between Objects
-- @comments The number of other Classes that are coupled to the current one. Two Classes are coupled when methods declared in one Class use Methods or instance variables defined by the other Class.
helper context MDEPTH!NodeType def: CBO() : Integer =
 self.coupledClasses->size(); -- @end helper MOOSE::CBO
-- @begin helper MOOSE::RFC
-- @comments Response for a Class
-- @comments The number of Methods in the current Class that might respond to a message received by its object, including Methods both inside and outside of this Class.
-- @comments RFC={M} ∪all i {Ri} where {Ri} = set of Methods called by Method i and {M} = set of all Methods in a Class. Ri is dependent on the implementation of the Method i.
-- @end helper MOOSE::CBO
-- @begin helper MOOSE::RFC
-- @comments Response for a Class
-- @comments The number of Methods in the current Class that might respond to a message received by its object, including Methods both inside and outside of this Class.
-- @comments RFC={M} ∪all i {Ri} where {Ri} = set of Methods called by Method i and {M} = set of all Methods in a Class. Ri is dependent on the implementation of the Method i.
helper context MDEPTH!NodeType def: RFC() : Integer =
 self.allOperations->union(self.allOperations->collect(o |
  o.method->collect(m |
   m.allClients
  )->flatten()->asSet()->select(c |
   c.oclAsType(MDEPTH!NONE)
  )
 ))->flatten()->asSet()->size(); -- @end helper MOOSE::RFC
-- ================
-- EMOOSE Metrics =
-- ================
-- @begin helper EMOOSE::NOM
-- @comments Number of Methods
-- @comments Number of Operations that are local to the Class, i.e., that can only be accessed by other Class Operations (and not in other Classes).
-- @comments The Class must have some Operations.
-- @end helper MOOSE::RFC
-- ================
-- EMOOSE Metrics =
-- ================
-- @begin helper EMOOSE::NOM
-- @comments Number of Methods
-- @comments Number of Operations that are local to the Class, i.e., that can only be accessed by other Class Operations (and not in other Classes).
-- @comments The Class must have some Operations.
helper context MDEPTH!NodeType def: NOM2() : Integer =
 self.allOperations->select(o |
  o.visibility = #private
 )->size(); -- @end helper EMOOSE::NOM
-- @begin helper EMOOSE::SIZE2
-- @comments Number of local Attributes and Operations defined in the Class.
-- @end helper EMOOSE::NOM
-- @begin helper EMOOSE::SIZE2
-- @comments Number of local Attributes and Operations defined in the Class.
helper context MDEPTH!NodeType def: SIZE2() : Integer =
 self.DON() + self.DAN(); -- @end helper EMOOSE::SIZE2
--******************************************************************************************************
--******************************************************************************************************
--uses FLAME4UML2;
--******************************************************************************************************
--******************************************************************************************************
-- @begin attribute helper coupledClasses
-- @comments Set of Classs to which the current Class is coupled (excluding inheritance).
-- @end helper EMOOSE::SIZE2
--******************************************************************************************************
--******************************************************************************************************
--uses FLAME4UML2;
--******************************************************************************************************
--******************************************************************************************************
-- @begin attribute helper coupledClasses
-- @comments Set of Classs to which the current Class is coupled (excluding inheritance).
helper context MDEPTH!NodeType def: coupledClasses : Set(MDEPTH!NodeType) =
 self.allAttributesTypes->union(self.allParametersTypes); -- @end attribute helper coupledClasses
-- @begin attribute helper newFeatures
-- @comments Sequence of Features declared in the current Class. This definition excludes inherited Features (and consequently, it excludes overridden Features).
-- @end attribute helper coupledClasses
-- @begin attribute helper newFeatures
-- @comments Sequence of Features declared in the current Class. This definition excludes inherited Features (and consequently, it excludes overridden Features).
helper context MDEPTH!NodeType def: newFeatures : Sequence(MDEPTH!NONE) =
 self.newAttributes->union(self.newOperations); -- @end attribute helper newFeatures
-- @begin attribute helper definedFeatures
-- @comments Sequence of Features declared in the Class, including overridden Features.
-- @end attribute helper newFeatures
-- @begin attribute helper definedFeatures
-- @comments Sequence of Features declared in the Class, including overridden Features.
helper context MDEPTH!NodeType def: definedFeatures : Sequence(MDEPTH!NONE) =
 self.definedAttributes->union(self.definedOperations); -- @end attribute helper definedFeatures
-- @begin attribute helper directlyInheritedFeatures
-- @comments Sequence of directly inherited Features.
-- @end attribute helper definedFeatures
-- @begin attribute helper directlyInheritedFeatures
-- @comments Sequence of directly inherited Features.
helper context MDEPTH!NodeType def: directlyInheritedFeatures : Sequence(MDEPTH!NONE) =
 self.directlyInheritedAttributes->union(self.directlyInheritedOperations); -- @end attribute helper directlyInheritedFeatures
-- @begin attribute helper allInheritedFeatures
-- @comments Sequence containing all Features of the Class itself and all its inherited Features (both directly and indirectly).
-- @end attribute helper directlyInheritedFeatures
-- @begin attribute helper allInheritedFeatures
-- @comments Sequence containing all Features of the Class itself and all its inherited Features (both directly and indirectly).
helper context MDEPTH!NodeType def: allInheritedFeatures : Sequence(MDEPTH!NONE) =
 self.allInheritedAttributes->union(self.allInheritedOperations); -- @end attribute helper allInheritedFeatures
-- @begin attribute helper overriddenFeatures
-- @comments Sequence of redefined Features in the Class.
-- @end attribute helper allInheritedFeatures
-- @begin attribute helper overriddenFeatures
-- @comments Sequence of redefined Features in the Class.
helper context MDEPTH!NodeType def: overriddenFeatures : Sequence(MDEPTH!NONE) =
 self.overriddenAttributes->union(self.overriddenOperations); -- @end attribute helper overriddenFeatures
-- @begin attribute helper allFeatures
-- @comments Sequence containing all Features of the Class itself and all its inherited Features.
-- @end attribute helper overriddenFeatures
-- @begin attribute helper allFeatures
-- @comments Sequence containing all Features of the Class itself and all its inherited Features.
helper context MDEPTH!NodeType def: allFeatures : Sequence(MDEPTH!NONE) =
 self.allAttributes->union(self.allOperations); -- @end attribute helper allFeatures
-- @begin attribute helper newAttributes
-- @comments Sequence of Attributes declared in the current Class.
-- @end attribute helper allFeatures
-- @begin attribute helper newAttributes
-- @comments Sequence of Attributes declared in the current Class.
helper context MDEPTH!NodeType def: newAttributes : Sequence(MDEPTH!Property) =
 self.definedAttributes->select(da |
  self.allInheritedAttributes->collect(ia |
   ia.name
  )->excludes(da.name)
 ); -- @end attribute helper newAttributes
-- @begin attribute helper definedAttributes
-- @comments Sequence of Properties declared in the Class, including overridden Properties.
-- @end attribute helper newAttributes
-- @begin attribute helper definedAttributes
-- @comments Sequence of Properties declared in the Class, including overridden Properties.
helper context MDEPTH!NodeType def: definedAttributes : Sequence(MDEPTH!Property) =
 self.ownedAttribute;

-- @end attribute helper definedAttributes
-- @begin attribute helper directlyInheritedAttributes
-- @comments Sequence of directly inherited Properties.
helper context MDEPTH!NodeType def: directlyInheritedAttributes : Sequence(MDEPTH!Property) =
 self.parents->iterate(p; acc : Sequence(MDEPTH!Property) = Sequence {} |
  acc->union(p.newAttributes)
 ); -- @end attribute helper directlyInheritedAttributes
-- @begin attribute helper allInheritedAttributes
-- @comments Sequence of all inherited Properties (both directly and indirectly).
-- @end attribute helper directlyInheritedAttributes
-- @begin attribute helper allInheritedAttributes
-- @comments Sequence of all inherited Properties (both directly and indirectly).
helper context MDEPTH!NodeType def: allInheritedAttributes : Sequence(MDEPTH!Property) =
 self.directlyInheritedAttributes->union(self.parents->collect(p |
  p.allInheritedAttributes
 )->flatten()); -- @end attribute helper allInheritedAttributes
-- @begin attribute helper overriddenAttributes
-- @comments Sequence of redefined Properties in the Class.
-- @end attribute helper allInheritedAttributes
-- @begin attribute helper overriddenAttributes
-- @comments Sequence of redefined Properties in the Class.
helper context MDEPTH!NodeType def: overriddenAttributes : Sequence(MDEPTH!Property) =
 self.definedAttributes->select(da |
  self.allInheritedAttributes->collect(ia |
   ia.name
  )->includes(da.name)
 ); -- @end attribute helper overriddenAttributes
-- @begin attribute helper allAttributes
-- @comments Sequence containing all Properties of the Class itself and all its inherited Properties (both directly and indirectly).
-- @end attribute helper overriddenAttributes
-- @begin attribute helper allAttributes
-- @comments Sequence containing all Properties of the Class itself and all its inherited Properties (both directly and indirectly).
helper context MDEPTH!NodeType def: allAttributes : Sequence(MDEPTH!Property) =
 self.definedAttributes->union(self.allInheritedAttributes->reject(ia |
  self.overriddenAttributes->collect(oa |
   oa.name
  )->includes(ia.name)
 ));

-- @end attribute helper allAttributes
-- @begin attribute helper allAttributesTypes
-- @comments Set containing all Types of all Attribtues of the Class.
helper context MDEPTH!NodeType def: allAttributesTypes : Set(MDEPTH!NodeType) =
 self.allAttributes->collect(a |
  a.type
 )->flatten()->select(t |
  t.oclIsTypeOf(MDEPTH!NodeType)
 )->asSet(); -- @end attribute helper allAttributesTypes
-- @begin attribute helper newOperations
-- @comments Sequence of Operations declared in the current Class.
-- @end attribute helper allAttributesTypes
-- @begin attribute helper newOperations
-- @comments Sequence of Operations declared in the current Class.
helper context MDEPTH!NodeType def: newOperations : Sequence(MDEPTH!NONE) =
 self.definedOperations->select(dop |
  self.allInheritedOperations->collect(iop |
   iop.name
  )->excludes(dop.name)
 ); -- @end attribute helper newOperations
-- @begin attribute helper definedOperations
-- @comments Sequence of Operations declared in the Class, including overridden Operations.
-- @end attribute helper newOperations
-- @begin attribute helper definedOperations
-- @comments Sequence of Operations declared in the Class, including overridden Operations.
helper context MDEPTH!NodeType def: definedOperations : Sequence(MDEPTH!NONE) =
 self.ownedOperation;

-- @end attribute helper definedOperations
-- @begin attribute helper directlyInheritedOperations
-- @comments Sequence of directly inherited Operations.
helper context MDEPTH!NodeType def: directlyInheritedOperations : Sequence(MDEPTH!NONE) =
 self.parents->iterate(p; acc : Sequence(MDEPTH!NONE) = Sequence {} |
  acc->union(p.newOperations)
 ); -- @end attribute helper directlyInheritedOperations
-- @begin attribute helper allInheritedOperations
-- @comments Sequence containing all Operations of the Class itself and all its inherited Operations (both directly and indirectly).
-- @end attribute helper directlyInheritedOperations
-- @begin attribute helper allInheritedOperations
-- @comments Sequence containing all Operations of the Class itself and all its inherited Operations (both directly and indirectly).
helper context MDEPTH!NodeType def: allInheritedOperations : Sequence(MDEPTH!NONE) =
 self.directlyInheritedOperations->union(self.parents->collect(p |
  p.allInheritedOperations
 )->flatten()); -- @end attribute helper allInheritedOperations
-- @begin attribute helper overriddenOperations
-- @comments Sequence of redefined Operations in the Class.
-- @end attribute helper allInheritedOperations
-- @begin attribute helper overriddenOperations
-- @comments Sequence of redefined Operations in the Class.
helper context MDEPTH!NodeType def: overriddenOperations : Sequence(MDEPTH!NONE) =
 self.definedOperations->select(dop |
  self.allInheritedOperations->collect(iop |
   iop.name
  )->includes(dop.name)
 ); -- @end attribute helper overriddenOperations
-- @begin attribute helper allOperations
-- @comments Sequence containing all Operations of the Class itself and all its inherited Operations.
-- @end attribute helper overriddenOperations
-- @begin attribute helper allOperations
-- @comments Sequence containing all Operations of the Class itself and all its inherited Operations.
helper context MDEPTH!NodeType def: allOperations : Sequence(MDEPTH!NONE) =
 self.definedOperations->union(self.allInheritedOperations->reject(iop |
  self.overriddenOperations->collect(oop |
   oop.name
  )->includes(iop.name)
 ));

-- @end attribute helper allOperations
-- @begin attribute helper allParameters
-- @comments Set containing all Parameters of all Operations of the Class.
helper context MDEPTH!NodeType def: allParameters : Set(MDEPTH!Parameter) =
 self.allOperations->collect(o |
  o.ownedParameter
 )->flatten()->select(t |
  t.oclIsTypeOf(MDEPTH!NodeType)
 )->asSet(); -- @end attribute helper allParameters
-- @begin attribute helper allParametersTypes
-- @comments Set containing all Types of all Parameters of all Operations of the Class.
-- @end attribute helper allParameters
-- @begin attribute helper allParametersTypes
-- @comments Set containing all Types of all Parameters of all Operations of the Class.
helper context MDEPTH!NodeType def: allParametersTypes : Set(MDEPTH!NodeType) =
 self.allParameters->collect(param |
  param.type
 )->flatten()->select(t |
  t.oclIsTypeOf(MDEPTH!NodeType)
 )->asSet();

-- @end attribute helper allParametersTypes
-- @begin attribute helper isRoot
-- @comments Indicates whether the Class has ascendants or not. A true value indicates it has no ascendants and a false value indicates it has ascendants.
helper context MDEPTH!NodeType def: isRoot : Boolean =
 self.parents->isEmpty(); -- @end attribute helper isRoot
-- @begin attribute helper isLeaf
-- @comments Indicates whether the Class has descendants or not. A true value indicates it has no descendants and a false value indicates it has descendants.
-- @end attribute helper isRoot
-- @begin attribute helper isLeaf
-- @comments Indicates whether the Class has descendants or not. A true value indicates it has no descendants and a false value indicates it has descendants.
helper context MDEPTH!NodeType def: isLeaf : Boolean =
 self.children->isEmpty(); -- @end attribute helper isLeaf
-- @begin attribute helper children
-- @comments Set of directly derived Classs of the current Class.
-- @end attribute helper isLeaf
-- @begin attribute helper children
-- @comments Set of directly derived Classs of the current Class.
helper context MDEPTH!NodeType def: children : Set(MDEPTH!NodeType) =
 MDEPTH!Generalization.allInstances()->select(g |
  g.general = self
 )->collect(g |
  g.specific
 )->excluding(self)->asSet(); -- @end attribute helper children
-- @begin attribute helper descendants
-- @comments Set of all derived Classs (both directly and indirectly).
-- @end attribute helper children
-- @begin attribute helper descendants
-- @comments Set of all derived Classs (both directly and indirectly).
helper context MDEPTH!NodeType def: descendants : Set(MDEPTH!NodeType) =
 self.children->iterate(c; acc : Set(MDEPTH!NodeType) = self.children |
  acc->union(c.descendants)
 ); -- @end attribute helper descendants
-- @begin attribute helper parents
-- @comments Set of Classs from which the current Class derives directly.
-- @end attribute helper descendants
-- @begin attribute helper parents
-- @comments Set of Classs from which the current Class derives directly.
helper context MDEPTH!NodeType def: parents : Set(MDEPTH!NodeType) =
 self.generalization->collect(g |
  g.general
 )->excluding(self)->asSet(); -- @end attribute helper parents
-- @begin attribute helper ascendants
-- @comments Set of all classes from which the current Class derives (both directly and indirectly).
-- @end attribute helper parents
-- @begin attribute helper ascendants
-- @comments Set of all classes from which the current Class derives (both directly and indirectly).
helper context MDEPTH!NodeType def: ascendants : Set(MDEPTH!NodeType) =
 self.parents->iterate(c; acc : Set(MDEPTH!NodeType) = self.parents |
  acc->union(c.ascendants)
 ); -- @end attribute helper ascendants
-- @begin attribute helper client
-- @comments Set containing all direct clients of the NamedElement.
-- @end attribute helper owner
-- @begin helper AUN
-- @comments Attribute Use Number
-- @comments Number of NamedElement that use the Property (excludes the NamedElement where the Property is declared).
helper context MDEPTH!Property def: AUN() : Integer =
 self.FUN(); -- @end helper AUN
-- @begin helper FCV
-- @comments Feature to Class Visibility
-- @comments Indicates if a Class can access the Feature.
-- @end helper AUN
-- @begin helper FCV
-- @comments Feature to Class Visibility
-- @comments Indicates if a Class can access the Feature.
helper context MDEPTH!NodeType def: FCV(f : MDEPTH!NONE) : Boolean =
 f.visibility = #public or self.allFeatures->includes(f) or f.visibility = #protected and self.ascendants->exists(c |
  c.allFeatures->includes(f)
 ); -- @end helper FCV
-- @begin helper NAN
-- @comments New Attributes Number
-- @comments Number of new Properties belonging to the Class.
-- @end helper FCV
-- @begin helper NAN
-- @comments New Attributes Number
-- @comments Number of new Properties belonging to the Class.
helper context MDEPTH!NodeType def: NAN() : Integer =
 self.newAttributes->size(); -- @end helper NAN
-- @begin helper DAN
-- @comments Defined Attributes Number
-- @comments Number of defined Properties in the Class.
-- @end helper NAN
-- @begin helper DAN
-- @comments Defined Attributes Number
-- @comments Number of defined Properties in the Class.
helper context MDEPTH!NodeType def: DAN() : Integer =
 self.definedAttributes->size(); -- @end helper DAN
-- @begin helper IAN
-- @comments Inherited Attributes Number
-- @comments Number of inherited Properties in the Class.
-- @end helper DAN
-- @begin helper IAN
-- @comments Inherited Attributes Number
-- @comments Number of inherited Properties in the Class.
helper context MDEPTH!NodeType def: IAN() : Integer =
 self.allInheritedAttributes->size(); -- @end helper IAN
-- @begin helper OAN
-- @comments Overridden Attributes Number
-- @comments Number of overridden Properties in the Class.
-- @end helper IAN
-- @begin helper OAN
-- @comments Overridden Attributes Number
-- @comments Number of overridden Properties in the Class.
helper context MDEPTH!NodeType def: OAN() : Integer =
 self.overriddenAttributes->size(); -- @end helper OAN
-- @begin helper AAN
-- @comments Available Attributes Number
-- @comments Number of Properties in the Class.
-- @end helper OAN
-- @begin helper AAN
-- @comments Available Attributes Number
-- @comments Number of Properties in the Class.
helper context MDEPTH!NodeType def: AAN() : Integer =
 self.allAttributes->size(); -- @end helper AAN
-- @begin helper NON
-- @comments New Operations Number
-- @comments Number of new Operations in the Class.
-- @end helper AAN
-- @begin helper NON
-- @comments New Operations Number
-- @comments Number of new Operations in the Class.
helper context MDEPTH!NodeType def: NON() : Integer =
 self.newOperations->size(); -- @end helper NON
-- @begin helper DON
-- @comments Defined Operations Number
-- @comments Number of defined Operations in the Class.
-- @end helper NON
-- @begin helper DON
-- @comments Defined Operations Number
-- @comments Number of defined Operations in the Class.
helper context MDEPTH!NodeType def: DON() : Integer =
 self.definedOperations->size(); -- @end helper DON
-- @begin helper ION
-- @comments Inherited Operations Number
-- @comments Number of inherited Operations in the Class.
-- @end helper DON
-- @begin helper ION
-- @comments Inherited Operations Number
-- @comments Number of inherited Operations in the Class.
helper context MDEPTH!NodeType def: ION() : Integer =
 self.allInheritedOperations->size(); -- @end helper ION
-- @begin helper OON
-- @comments Overridden Operations Number
-- @comments Number of overridden Operations in the Class.
-- @end helper ION
-- @begin helper OON
-- @comments Overridden Operations Number
-- @comments Number of overridden Operations in the Class.
helper context MDEPTH!NodeType def: OON() : Integer =
 self.overriddenOperations->size(); -- @end helper OON
-- @begin helper AON
-- @comments Available Operations Number
-- @comments Number of Operations in the Class.
-- @end helper OON
-- @begin helper AON
-- @comments Available Operations Number
-- @comments Number of Operations in the Class.
helper context MDEPTH!NodeType def: AON() : Integer =
 self.allOperations->size(); -- @end helper AON
-- @begin helper PRIAN
-- @comments PRIvate Attributes Number
-- @comments Number of private Properties in the Class.
-- @end helper AON
-- @begin helper PRIAN
-- @comments PRIvate Attributes Number
-- @comments Number of private Properties in the Class.
helper context MDEPTH!NodeType def: PRIAN() : Integer =
 self.allAttributes->select(a |
  a.visibility = #private
 )->size(); -- @end helper PRIAN
-- @begin helper PROAN
-- @comments PROtected Properties Number
-- @comments Number of protected Attributes in the Class.
-- @end helper PRIAN
-- @begin helper PROAN
-- @comments PROtected Properties Number
-- @comments Number of protected Attributes in the Class.
helper context MDEPTH!NodeType def: PROAN() : Integer =
 self.allAttributes->select(a |
  a.visibility = #protected
 )->size(); -- @end helper PROAN
-- @begin helper PUBAN
-- @comments PUBlic Properties Number
-- @comments Number of public Attributes in the Class.
-- @end helper PROAN
-- @begin helper PUBAN
-- @comments PUBlic Properties Number
-- @comments Number of public Attributes in the Class.
helper context MDEPTH!NodeType def: PUBAN() : Integer =
 self.allAttributes->select(a |
  a.visibility = #public
 )->size(); -- @end helper PUBAN
-- @begin helper PRION
-- @comments PRIvate Operations Number
-- @comments Number of private Operations in the Class.
-- @end helper PUBAN
-- @begin helper PRION
-- @comments PRIvate Operations Number
-- @comments Number of private Operations in the Class.
helper context MDEPTH!NodeType def: PRION() : Integer =
 self.allOperations->select(op |
  op.visibility = #private
 )->size(); -- @end helper PRION
-- @begin helper PROON
-- @comments PROtected Operations Number
-- @comments Number of protected Operations in the Class.
-- @end helper PRION
-- @begin helper PROON
-- @comments PROtected Operations Number
-- @comments Number of protected Operations in the Class.
helper context MDEPTH!NodeType def: PROON() : Integer =
 self.allOperations->select(op |
  op.visibility = #protected
 )->size(); -- @end helper PROON
-- @begin helper PUBON
-- @comments PUBlic Operations Number
-- @comments Number of public Operations in the Class.
-- @end helper PROON
-- @begin helper PUBON
-- @comments PUBlic Operations Number
-- @comments Number of public Operations in the Class.
helper context MDEPTH!NodeType def: PUBON() : Integer =
 self.allOperations->select(op |
  op.visibility = #public
 )->size(); -- @end helper PUBON
-- @begin helper FUN
-- @comments Feature Use Number
-- @comments Number of NamedElement that use the Feature (excludes the NamedElement where the Feature is declared).
-- @end helper FUN
-- @begin helper CHIN
-- @comments CHIldren Number
-- @comments Number of directly derived Classs.
helper context MDEPTH!NodeType def: CHIN() : Integer =
 self.children->size(); -- @end helper CHIN
-- @begin helper DESN
-- @comments DEScendants Number
-- @comments Number of all derived Classs (both directly and indirectly).
-- @end helper CHIN
-- @begin helper DESN
-- @comments DEScendants Number
-- @comments Number of all derived Classs (both directly and indirectly).
helper context MDEPTH!NodeType def: DESN() : Integer =
 self.descendants->size(); -- @end helper DESN
-- @begin helper PARN
-- @comments PARents Number
-- @comments Number of Classs from which the current Class derives directly.
-- @end helper DESN
-- @begin helper PARN
-- @comments PARents Number
-- @comments Number of Classs from which the current Class derives directly.
helper context MDEPTH!NodeType def: PARN() : Integer =
 self.parents->size(); -- @end helper PARN
-- @begin helper ASCN
-- @comments ASCendants Number
-- @comments Number of Classs from which the current Class derives (both directly and indirectly).
-- @end helper PARN
-- @begin helper ASCN
-- @comments ASCendants Number
-- @comments Number of Classs from which the current Class derives (both directly and indirectly).
helper context MDEPTH!NodeType def: ASCN() : Integer =
 self.ascendants->size(); -- @end helper ASCN
-- @begin helper OUN
-- @comments Operation Use Number
-- @comments Number of NamedElement that use the Operation (excludes the NamedElement where the Feature is declared).
-- @end helper QMOOD::ANA
-- @comments This metrics is not used because result can be negative.
-- @begin helper QMOOD::MFM
-- @comments Measure of Functional Modularity
-- @comments Computes modularity based on the deviation of the number of Methods in a Class from the average number of Methods per Class in the design.
-- @comments A value closer than zero is preferred for this metric. A lower value indicates a smaller deviation among Classes in the number of services provided.
--helper context UML2!Class
--def : MFM() : Integer =
--	let owner : UML2!Package = self.owner in
--	if not owner.oclIsUndefined()
--		then if owner.CN() > 0
--				then if owner.PAON() / owner.CN() > 0
--						then (self.allOperations->size() -
--							  (owner.PAON() / owner.CN())) /
--							  	(owner.PAON() / owner.CN())
--						else 0
--					endif
--				else 0
--			endif
--		else 0
--	endif;
-- @end helper QMOOD::MFM
-- @begin helper QMOOD::MFA
-- @comments Measure of Functional Abstraction
-- @comments The ratio of the number of Methods inherited by a class to the total number of Methods accessible by members in the Class.
-- @comments In order to calculate MFA, the number of Operations must be greater than zero.
helper context MDEPTH!NodeType def: MFA() : Integer =
 if self.AON() > 0 then
  self.ION() / self.allOperations->iterate(o; acc : Integer = 0 |
   if self.FCV(o) then
    acc + 1
   else
    acc
   endif
  )
 else
  0
 endif; -- @end helper QMOOD::MFA
-- @begin helper QMOOD::MAA
-- @comments Measure of Attribute Abstraction
-- @comments The ratio of the number of Attributes inherited by a Class to the total number of Attributes in the Class.
-- @comments In order to calculate MAA, number of attributes must be greater than zero.
-- @end helper QMOOD::MFA
-- @begin helper QMOOD::MAA
-- @comments Measure of Attribute Abstraction
-- @comments The ratio of the number of Attributes inherited by a Class to the total number of Attributes in the Class.
-- @comments In order to calculate MAA, number of attributes must be greater than zero.
helper context MDEPTH!NodeType def: MAA() : Integer =
 let nbFCV : Integer = self.allAttributes->iterate(a; acc : Integer = 0 |
  if self.FCV(a) then
   acc + 1
  else
   acc
  endif
 ) in
 if nbFCV > 0 then
  self.IAN() / nbFCV
 else
  0
 endif; -- @end helper QMOOD::MAA
-- @begin helper QMOOD::MAT
-- @comments Measure of Abstraction
-- @comments The average of functional and attribute abstraction measures.
-- @end helper QMOOD::MAA
-- @begin helper QMOOD::MAT
-- @comments Measure of Abstraction
-- @comments The average of functional and attribute abstraction measures.
helper context MDEPTH!NodeType def: MAT() : Integer =
 (self.MFA() + self.MAA()) / 2; -- @end helper QMOOD::MAT
-- @begin helper QMOOD::MOA
-- @comments Measure of Aggregation
-- @comments Count of the number of data declarations whose types are user defined Classes.
-- @end helper QMOOD::MAT
-- @begin helper QMOOD::MOA
-- @comments Measure of Aggregation
-- @comments Count of the number of data declarations whose types are user defined Classes.
helper context MDEPTH!NodeType def: MOA() : Integer =
 let owner : MDEPTH!NONE = self.owner in
 if not owner.oclIsUndefined() then
  self.allAttributes->iterate(a; acc : Integer = 0 |
   if owner.allClasses->includes(a.type) then
    acc + 1
   else
    acc
   endif
  )
 else
  0
 endif; -- @end helper QMOOD::MOA
-- @begin helper QMOOD::MRM
-- @comments Modeled Relationship Measure
-- @comments Measure of the total number of Attribute and Parameter based relationships in a Class.
-- @end helper QMOOD::MOA
-- @begin helper QMOOD::MRM
-- @comments Modeled Relationship Measure
-- @comments Measure of the total number of Attribute and Parameter based relationships in a Class.
helper context MDEPTH!NodeType def: MRM() : Integer =
 self.DCC() + self.NAD(); -- @end helper QMOOD::MRM
-- @begin helper QMOOD::DAM
-- @comments Data Access Metric
-- @comments The ratio of the number of private Attributes to the total number of Attributes declared in a Class.
-- @comments A high value of DAM is desired. The pre-condition states that the Class must have Attributes.
-- @end helper QMOOD::MRM
-- @begin helper QMOOD::DAM
-- @comments Data Access Metric
-- @comments The ratio of the number of private Attributes to the total number of Attributes declared in a Class.
-- @comments A high value of DAM is desired. The pre-condition states that the Class must have Attributes.
helper context MDEPTH!NodeType def: DAM() : Integer =
 if self.AAN() > 0 then
  self.PRIAN() / self.AAN()
 else
  0
 endif; -- @end helper QMOOD::DAM
-- @begin helper QMOOD::OAM
-- @comments Operation Access Metric
-- @comments The ratio of the number of public Methods to the total number of Methods declared in the Class.
-- @comments A high value for OAM is desired. The pre-condition states that the Class must have Operations.
-- @end helper QMOOD::DAM
-- @begin helper QMOOD::OAM
-- @comments Operation Access Metric
-- @comments The ratio of the number of public Methods to the total number of Methods declared in the Class.
-- @comments A high value for OAM is desired. The pre-condition states that the Class must have Operations.
helper context MDEPTH!NodeType def: OAM() : Integer =
 if self.AON() > 0 then
  self.PUBON() / self.AON()
 else
  0
 endif; -- @end helper QMOOD::OAM
-- @begin helper QMOOD::MAM
-- @comments Member Access Metric
-- @comments This metric computes the access to all the members (Attributes and Methods) of a Class.
-- @comments A high value for MAM is desired.
-- @end helper QMOOD::OAM
-- @begin helper QMOOD::MAM
-- @comments Member Access Metric
-- @comments This metric computes the access to all the members (Attributes and Methods) of a Class.
-- @comments A high value for MAM is desired.
helper context MDEPTH!NodeType def: MAM() : Integer =
 (1 - self.DAM() + self.OAM()) / 2; -- @end helper QMOOD::MAM
-- @begin helper QMOOD::NOA
-- @comments Number of Ancestors
-- @comments Counts the number of distinct Classes which a Class inherits.
-- @end helper QMOOD::MAM
-- @begin helper QMOOD::NOA
-- @comments Number of Ancestors
-- @comments Counts the number of distinct Classes which a Class inherits.
helper context MDEPTH!NodeType def: NOA() : Integer =
 self.ASCN(); -- @end helper QMOOD::NOA
-- @begin helper QMOOD::NOM
-- @comments Number of Methods
-- @comments Count of all the Methods defined in a Class.
-- @end helper QMOOD::NOA
-- @begin helper QMOOD::NOM
-- @comments Number of Methods
-- @comments Count of all the Methods defined in a Class.
helper context MDEPTH!NodeType def: NOM() : Integer =
 self.AON(); -- @end helper QMOOD::NOM
-- @begin helper QMOOD::CIS
-- @comments Class Interface Size
-- @comments Number of public Methods in a Class.
-- @end helper QMOOD::NOM
-- @begin helper QMOOD::CIS
-- @comments Class Interface Size
-- @comments Number of public Methods in a Class.
helper context MDEPTH!NodeType def: CIS() : Integer =
 self.PUBON(); -- @end helper QMOOD::CIS
-- @begin helper QMOOD::NPT
-- @comments Number of Unique Parameter Types
-- @comments Number of different Parameter types used in the Methods of the Class.
-- @end helper QMOOD::CIS
-- @begin helper QMOOD::NPT
-- @comments Number of Unique Parameter Types
-- @comments Number of different Parameter types used in the Methods of the Class.
helper context MDEPTH!NodeType def: NPT() : Integer =
 self.allParametersTypes->size(); -- @end helper QMOOD::NPT
-- @begin helper QMOOD::NPM
-- @comments Number of Parameters per Method
-- @comments Average of the number of Parameters per Method in the Class. Computed by summing the Parameters of all Methods and dividing by the number of Methods in the Class.
-- @comments The pre-condition states the Class must have some Operations.
-- @end helper QMOOD::NPT
-- @begin helper QMOOD::NPM
-- @comments Number of Parameters per Method
-- @comments Average of the number of Parameters per Method in the Class. Computed by summing the Parameters of all Methods and dividing by the number of Methods in the Class.
-- @comments The pre-condition states the Class must have some Operations.
helper context MDEPTH!NodeType def: NPM() : Integer =
 if self.AON() > 0 then
  self.allParameters->size() / self.AON()
 else
  0
 endif; -- @end helper QMOOD::NPM
-- @begin helper QMOOD::NOD
-- @comments Number of Attributes
-- @comments Number of Attributes in the Class.
-- @end helper QMOOD::NPM
-- @begin helper QMOOD::NOD
-- @comments Number of Attributes
-- @comments Number of Attributes in the Class.
helper context MDEPTH!NodeType def: NOD() : Integer =
 self.AAN(); -- @end helper QMOOD::NOD
-- @begin helper QMOOD::NAD
-- @comments Number of Abstract Data Types
-- @comments Number of user defined objects (ADTs) used as Attributes in the Class and which are necessary to instantiate an object instance of the (aggregate) Class.
-- @end helper QMOOD::NOD
-- @begin helper QMOOD::NAD
-- @comments Number of Abstract Data Types
-- @comments Number of user defined objects (ADTs) used as Attributes in the Class and which are necessary to instantiate an object instance of the (aggregate) Class.
helper context MDEPTH!NodeType def: NAD() : Integer =
 self.allAttributesTypes->size(); -- @end helper QMOOD::NAD
-- @begin helper QMOOD::NPA
-- @comments Number of Public Attributes
-- @comments Number of Attributes that are declared as public in the Class.
-- @end helper QMOOD::NAD
-- @begin helper QMOOD::NPA
-- @comments Number of Public Attributes
-- @comments Number of Attributes that are declared as public in the Class.
helper context MDEPTH!NodeType def: NPA() : Integer =
 self.PUBAN(); -- @end helper QMOOD::NPA
-- @begin helper QMOOD::CSM
-- @comments Class Size Metric
-- @comments Sum of the number of Methods and Attributes in the Class.
-- @end helper QMOOD::NPA
-- @begin helper QMOOD::CSM
-- @comments Class Size Metric
-- @comments Sum of the number of Methods and Attributes in the Class.
helper context MDEPTH!NodeType def: CSM() : Integer =
 self.AAN() + self.AON(); -- @end helper QMOOD::CSM
-- @begin helper QMOOD::CAM
-- @comments Cohesion Among Methods of Class
-- @comments Computes the relatedness among Methods of the Class based upon the Parameter list of the Methods.
-- @comments The metrics is computed using the summation of the intersection of Parameters of a Method with the maximum independent set of all Parameter types in the Class.
-- @end helper QMOOD::CSM
-- @begin helper QMOOD::CAM
-- @comments Cohesion Among Methods of Class
-- @comments Computes the relatedness among Methods of the Class based upon the Parameter list of the Methods.
-- @comments The metrics is computed using the summation of the intersection of Parameters of a Method with the maximum independent set of all Parameter types in the Class.
helper context MDEPTH!NodeType def: CAM() : Integer =
 let divisor : Integer = self.AON() * self.allParametersTypes->size() in
 if divisor > 0 then
  self.allOperations->iterate(o; acc : Integer = 0 |
   acc + o.allParametersTypes->size()
  ) / divisor
 else
  0
 endif; -- @end helper QMOOD::CAM
-- @begin helper QMOOD::DCC
-- @comments Direct Class Coupling
-- @comments Count of the different number of Classes that a Class is directly related to. The metric includes Classes that are directly related by Attribute declarations and message passing (Parameters) in Methods.
-- @end helper QMOOD::CAM
-- @begin helper QMOOD::DCC
-- @comments Direct Class Coupling
-- @comments Count of the different number of Classes that a Class is directly related to. The metric includes Classes that are directly related by Attribute declarations and message passing (Parameters) in Methods.
helper context MDEPTH!NodeType def: DCC() : Integer =
 self.allAttributesTypes->union(self.allParametersTypes)->size(); -- @end helper QMOOD::DCC
-- @begin helper QMOOD::MCC
-- @comments Maximum Class Coupling
-- @comments This metric not only includes Classes that are directly related to a Class by Attributes and Methods, but also Classes that are indirectly related through the directly related Classes.
-- @end helper QMOOD::DCC
-- @begin helper QMOOD::MCC
-- @comments Maximum Class Coupling
-- @comments This metric not only includes Classes that are directly related to a Class by Attributes and Methods, but also Classes that are indirectly related through the directly related Classes.
helper context MDEPTH!NodeType def: MCC() : Integer =
 self.allAttributesTypes->union(self.allParametersTypes)->iterate(t; acc : Sequence(MDEPTH!NodeType) = Sequence {} |
  acc->union(t.allAttributesTypes)->union(t.allParametersTypes)
 )->asSet()->size(); -- @end helper QMOOD::MCC
-- @begin helper QMOOD::DAC
-- @comments Direct Attribute Based Coupling
-- @comments This metric is a direct count of the number of different Class types that are declared as Attribute references inside a Class.
-- @end helper QMOOD::MCC
-- @begin helper QMOOD::DAC
-- @comments Direct Attribute Based Coupling
-- @comments This metric is a direct count of the number of different Class types that are declared as Attribute references inside a Class.
helper context MDEPTH!NodeType def: DAC() : Integer =
 self.allAttributesTypes->size(); -- @end helper QMOOD::DAC
-- @begin helper QMOOD::DPC
-- @comments Direct Parameter Based Coupling
-- @comments Number of Class object types that are required directly for a message passing (Parameters) to Methods in the Class.
-- @end helper QMOOD::DAC
-- @begin helper QMOOD::DPC
-- @comments Direct Parameter Based Coupling
-- @comments Number of Class object types that are required directly for a message passing (Parameters) to Methods in the Class.
helper context MDEPTH!NodeType def: DPC() : Integer =
 self.allParametersTypes->size(); -- @end helper QMOOD::DPC
-- @begin helper QMOOD::MPC
-- @comments Maximum Parameter Based Coupling
-- @comments Number of Class object types that are required directly and indirectly for message passing (Parameters) in the Class.
-- @end helper QMOOD::DPC
-- @begin helper QMOOD::MPC
-- @comments Maximum Parameter Based Coupling
-- @comments Number of Class object types that are required directly and indirectly for message passing (Parameters) in the Class.
helper context MDEPTH!NodeType def: MPC() : Integer =
 self.allParametersTypes->iterate(t; acc : Sequence(MDEPTH!NodeType) = Sequence {} |
  acc->union(t.allParametersTypes)
 )->asSet()->size(); -- @end helper QMOOD::MPC
-- @begin helper QMOOD::CCD
-- @comments Class Complexity Based on Data
-- @comments Computes complexity based upon the number of components (Attributes) that are defined in the Class.
-- @comments All component declarations are resolved to the basic primitives (integers, doubles and characters).
-- @comments The metric value is a count of the number of primitives.
-- @end helper QMOOD::MPC
-- @begin helper QMOOD::CCD
-- @comments Class Complexity Based on Data
-- @comments Computes complexity based upon the number of components (Attributes) that are defined in the Class.
-- @comments All component declarations are resolved to the basic primitives (integers, doubles and characters).
-- @comments The metric value is a count of the number of primitives.
helper context MDEPTH!NodeType def: CCD() : Integer =
 self.AAN() + self.allAttributesTypes->iterate(t; acc : Integer = 0 |
  acc + t.AAN()
 ); -- @end helper QMOOD::CCD
-- @begin helper QMOOD::CCP
-- @comments Class Complexity Based on Method Parameters
-- @comments Estimates complexity based upon the number of Parameters required to call Methods of the Class.
-- @comments Inherited Method Parameters are also included in the computation of the metric value.
-- @end helper QMOOD::CCD
-- @begin helper QMOOD::CCP
-- @comments Class Complexity Based on Method Parameters
-- @comments Estimates complexity based upon the number of Parameters required to call Methods of the Class.
-- @comments Inherited Method Parameters are also included in the computation of the metric value.
helper context MDEPTH!NodeType def: CCP() : Integer =
 self.allParameters->size(); -- @end helper QMOOD::CCP
-- @begin helper QMOOD::CCM
-- @comments Class Complexity Based on Members
-- @comments This metric is an aggregate of the data and method Parameter complexities.
-- @end helper QMOOD::CCP
-- @begin helper QMOOD::CCM
-- @comments Class Complexity Based on Members
-- @comments This metric is an aggregate of the data and method Parameter complexities.
helper context MDEPTH!NodeType def: CCM() : Integer =
 self.CCD() + self.CCP(); -- @end helper QMOOD::CCM
helper context MDEPTH!NodeType def: ownedOperation : OclAny =
 self.NONE;

helper context MDEPTH!NodeType def: ownedAttribute : OclAny =
 self.fields;

helper context MDEPTH!NodeType def: generalization : OclAny =
 self.extends;

helper context MDEPTH!ModelType def: packagedElement : OclAny =
 self.children;

helper context MDEPTH!NodeType def: nestedClassifier : OclAny =
 Sequence {};

helper context MDEPTH!NodeType def: visibility : OclAny =
 #public;

helper context MDEPTH!Property def: visibility : OclAny =
 #public;
-- @end helper QMOOD::CCM
