-- @atlcompiler atl2006
--Copyright (c) 2009 Mia-Software.
--All rights reserved. This program and the accompanying materials
--are made available under the terms of the Eclipse Public License v1.0
--which accompanies this distribution, and is available at
--http://www.eclipse.org/legal/epl-v10.html
---
--Contributors:
--	  Gabriel BARBIER (Mia-Software) - initial API and implementation
--    Fabien GIQUEL (Mia-Software) - initial API and implementation
--
-- @nsURI kdm=http://www.eclipse.org/MoDisco/kdm/action
-- @nsURI java=http://www.eclipse.org/MoDisco/Java/0.2.incubation/java


--
--Transform Java Models to KDM models

module javaToKdm;
create OUT: kdm from IN: java;

abstract rule TypeDeclarationToTemplateUnit {
	from
		src: java!TypeDeclaration (
			not src.typeParameters.isEmpty()
		)
	to
		tgt: kdm!TemplateUnit (
			name <- src -> getGenericName(),
			codeElement <- src.typeParameters,
			codeElement <- type
		),
		type: kdm!Datatype (
			name <- src.name,
			codeRelation <- src.superInterfaces -> collect(e | if (src.
					oclIsTypeOf(java!ClassDeclaration) ) then
						thisModule.CreateImplementsForTemplated(type, e)
					else
						thisModule.CreateExtendsForTemplated(type, e)
					endif),
			comment <- src.comments,
			comment <- if (src.originalCompilationUnit.oclIsUndefined() or not src.
					refImmediateComposite().oclIsTypeOf(java!Package) ) then
					Sequence { }
				else
					src.originalCompilationUnit.comments
				endif,
			source <- sourceRef,
			attribute <- if (src.modifier.oclIsUndefined() ) then
					Sequence { }
				else
					src.modifier
				endif,
			codeRelation <- src.annotations
		),
		sourceRef: kdm!SourceRef (
			language <- 'java',
			region <- sourceRegion
		),
		sourceRegion: kdm!SourceRegion (
			language <- 'java',
			file <- if (src.originalCompilationUnit.oclIsUndefined() ) then
					src.originalClassFile
				else
					src.originalCompilationUnit
				endif
		)
}

rule ClassDeclarationToTemplateUnit extends TypeDeclarationToTemplateUnit { 
   from
		src: java!ClassDeclaration (
			not src.typeParameters.isEmpty()
		)
using {
   javaAttributes: java!NamedElement = src.bodyDeclarations -> select(e | e.
		oclIsTypeOf(java!FieldDeclaration)) -> collect(f | if ( f.fragments->isEmpty() )
		then
   f
else
   f.fragments
endif);}
     to
		tgt: kdm!TemplateUnit,
		type: kdm!ClassUnit (
			isAbstract <- if (src.modifier.oclIsUndefined() ) then
					OclUndefined
				else
					src.modifier.inheritance = 'abstract'
				endif,
			codeElement <- javaAttributes,
			codeElement <- src.bodyDeclarations -> select(e | not e.
					oclIsTypeOf(java!FieldDeclaration))
		)
do {
   type.codeRelation <- if (src.superClass.oclIsUndefined() ) then
				Sequence { }
			else
				thisModule.CreateExtendsForTemplated(type, src.superClass)
			endif;
}
}

rule InterfaceDeclarationToTemplateUnit extends TypeDeclarationToTemplateUnit { 
   from
		src: java!InterfaceDeclaration (
			not src.typeParameters.isEmpty()
		)
using {
   javaAttributes: java!NamedElement = src.bodyDeclarations -> select(e | e.
		oclIsTypeOf(java!FieldDeclaration)) -> collect(f | if ( f.fragments->isEmpty() )
		then
   f
else
   f.fragments
endif);}
     to
		tgt: kdm!TemplateUnit,
		type: kdm!InterfaceUnit (
			codeElement <- javaAttributes,
			codeElement <- src.bodyDeclarations -> select(e | not e.
					oclIsTypeOf(java!FieldDeclaration))
		)

}

lazy rule CreateExtendsForTemplated {
	from targetFrom: kdm!CodeItem, sourceTo: java!TypeAccess
	to
		tgt: kdm!Extends (
			from <- targetFrom, -- Error starts here
			to <- sourceTo -> getType()
		)
}
