-- @path KM3=/bento.examples.analysis/third-party/usecases/modelsmeasurement/extra/KM3.ecore
-- @path Measure=/bento.examples.analysis/third-party/usecases/modelsmeasurement/metamodels/Measure.ecore

--@atlcompiler	atl2006
--@name			KM32Measure
--@version		2.1
--@domains		KM3, measurement data, metrics
--@authors		Eric Vepa (evepa <at> sodius.com) for SODIUS (www.sodius.com)
--@date			2007/08/02
--@description	This transformation is used to collect measurement data on a KM3 metamodel, using libraries implementing some metrics (MOOD, MOOD2, MOOSE, EMOOSE  and QMOOD).
--@see			Baroni, A.L.: Formal Definition of Object-Oriented Design Metrics. Master Thesis, Vrije University, Brussel, Belgium, 2002.

module KM32Measure; -- Module Template
create OUT : Measure from IN : KM3;

-- uses FLAME4KM3;

--@begin attribute helper coupledClasses
--@comments Set of Classes to which the current Class is coupled (excluding inheritance).
helper context KM3!Class
def : coupledClasses : Set(KM3!Classifier) =
    self.allFeatures->collect(sf|sf.type)->
        select(c|c.oclIsKindOf(KM3!Class))->asSet();
--@end attribute helper coupledClasses

--@begin attribute helper newFeatures
--@comments Sequence of Features declared in the current Class. This definition excludes inherited Features.
helper context KM3!Class
def : newFeatures : Sequence(KM3!StructuralFeature) =
    self.newAttributes()->union(self.newReferences);
--@end attribute helper newFeatures

--@begin attribute helper directlyInheritedFeatures
--@comments Sequence of directly inherited Features.
helper context KM3!Class
def : directlyInheritedFeatures : Sequence(KM3!StructuralFeature) =
    self.directlyInheritedAttributes->
        union(self.directlyInheritedReferences);
--@end attribute helper directlyInheritedFeatures

--@begin attribute helper allInheritedFeatures
--@comments Sequence containing all Features of the Class itself and all its inherited Features (both directly and indirectly).
helper context KM3!Class
def : allInheritedFeatures : Sequence(KM3!StructuralFeature) =
    self.allInheritedAttributes->union(self.allInheritedReferences);
--@end attribute helper allInheritedFeatures

--@begin attribute helper allFeatures
--@comments Sequence containing all Features of the Class itself and all its inherited Features.
helper context KM3!Class
def : allFeatures : Sequence(KM3!StructuralFeature) =
    self.allAttributes->union(self.allReferences);
--@end attribute helper allFeatures

--@begin attribute helper newAttributes
--@comments Sequence of Attributes and containment References declared in the current Class.
helper context KM3!Class
def : newAttributes : Sequence(KM3!StructuralFeature) =
    self.structuralFeatures->select(sf|sf.oclIsTypeOf(KM3!Attribute))->
        union(self.structuralFeatures->
            select(sf|sf.oclIsTypeOf(KM3!Reference))->select(r|r.isContainer));
--@end attribute helper newAttributes

--@begin attribute helper directlyInheritedAttributes
--@comments Sequence of directly inherited Attributes.
helper context KM3!Class
def : directlyInheritedAttributes : Sequence(KM3!StructuralFeature) =
    self.parents->collect(p|p.newAttributes)->flatten();
--@end attribute helper directlyInheritedAttributes

--@begin attribute helper allInheritedAttributes
--@comments Sequence of all inherited Attributes (both directly and indirectly).
helper context KM3!Class
def : allInheritedAttributes : Sequence(KM3!StructuralFeature) =
    self.directlyInheritedAttributes->
        union(self.parents->
            collect(p|p.allInheritedAttributes)->flatten());
--@end attribute helper allInheritedAttributes

--@begin attribute helper allAttributes
--@comments Sequence containing all Attributes of the Class itself and all its inherited Attributes (both directly and indirectly).
helper context KM3!Class
def : allAttributes : Sequence(KM3!StructuralFeature) =
    self.newAttributes->union(self.allInheritedAttributes);

helper context KM3!Package
def : allAttributes : Sequence(UML2!StructuralFeature) =
    self.allClasses->collect(c|c.allAttributes)->flatten();
--@end attribute helper allAttributes

--@begin attribute helper newReferences
--@comments Sequence of References (non containment) declared in the current Class.
helper context KM3!Class
def : newReferences : Sequence(KM3!Reference) =
    self.structuralFeatures->select(sf|sf.oclIsTypeOf(KM3!Reference))->
        select(r|not r.isContainer);
--@end attribute helper newReferences

--@begin attribute helper directlyInheritedReferences
--@comments Sequence of directly inherited References.
helper context KM3!Class
def : directlyInheritedReferences : Sequence(KM3!Reference) =
    self.parents->collect(p|p.newReferences)->flatten();
--@end attribute helper directlyInheritedReferences

--@begin attribute helper allInheritedReferences
--@comments Sequence containing all References of the Class itself and all its inherited References (both directly and indirectly).
helper context KM3!Class
def : allInheritedReferences : Sequence(KM3!Reference) =
    self.directlyInheritedReferences->
        union(self.parents->
            collect(p|p.allInheritedReferences)->flatten());
--@end attribute helper allInheritedReferences

--@begin attribute helper allReferences
--@comments Sequence containing all References of the Class itself and all its inherited References.
helper context KM3!Class
def : allReferences : Sequence(KM3!Reference) =
    self.newReferences->union(self.allInheritedReferences);
--@end attribute helper allReferences

--@begin attribute helper isRoot
--@comments Indicates whether the Class has ascendants or not. A true value indicates it has no ascendants and a false value indicates it has ascendants.
helper context KM3!Class
def : isRoot : Boolean =
    self.parents->isEmpty();
--@end attribute helper isRoot

--@begin attribute helper isLeaf
--@comments Indicates whether the Class has descendants or not. A true value indicates it has no descendants and a false value indicates it has descendants.
helper context KM3!Class
def : isLeaf : Boolean =
    self.children->isEmpty();
--@end attribute helper isLeaf

--@begin attribute helper children
--@comments Set of directly derived Classes of the current GeneralizableElement.
helper context KM3!Class
def : children : Set(KM3!Classifier) =
    KM3!Class.allInstances()->
        select(c|c.supertypes->includes(self))->asSet();
--@end attribute helper children

--@begin attribute helper descendants
--@comments Set of all derived Classes (both directly and indirectly).
helper context KM3!Class
def : descendants : Set(KM3!Classifier) =
    self.children->iterate(c; acc : Set(KM3!Classifier) = self.children|
        acc->union(c.descendants));
--@end attribute helper descendants

--@begin attribute helper parents
--@comments Set of Classes from which the current GeneralizableElement derives directly.
helper context KM3!Class
def : parents : Set(KM3!Classifier) =
    self.supertypes->excluding(self)->asSet();
--@end attribute helper parents

--@begin attribute helper ascendants
--@comments Set of all classes from which the current Class derives (both directly and indirectly).
helper context KM3!Class
def : ascendants : Set(KM3!Classifier) =
    self.parents->iterate(c; acc: Set(KM3!Classifier) = self.parents|
        acc->union(c.ascendants));
--@end attribute helper ascendants

--@begin attribute helper allClasses
--@comments Sequence of all Classes belonging to the current Package.
helper context KM3!Package
def : allClasses : Sequence(KM3!Class) =
    self.contents->select(c|c.oclIsKindOf(KM3!Class));
--@end attribute helper allClasses

--@begin attribute helper internalBaseClasses
--@comments Set of base Classes in the current Package.
helper context KM3!Package
def : internalBaseClasses : Set(KM3!Class) =
    self.allClasses->iterate(c; acc : Set(KM3!Class) = Set{}|
        acc->union(c.parents));
--@end attribute helper internalBaseClasses

--@begin attribute helper internalSupplierClasses
--@comments Set of supplier Classes in the current Package.
helper context KM3!Package
def : internalSupplierClasses : Set(KM3!Class) =
    self.supplierClasses(self);
--@end attribute helper internalSupplierClasses

--@begin helper FCV
--@comments Feature to Classifier Visibility
--@comments Indicates if a Class can access the Feature.
helper context KM3!Class
def : FCV(f : KM3!StructuralFeature) : Boolean =
	self.allFeatures->includes(f) or
		self.ascendants->exists(c|c.allFeatures->includes(f));
--@end helper FCV

--@begin helper NAN
--@comments New Attributes Number
--@comments Number of new Attributes belonging to the Class.
helper context KM3!Class
def : NAN() : Integer =
	self.newAttributes->size();
--@end helper NAN

--@begin helper IAN
--@comments Inherited Attributes Number
--@comments Number of inherited Attributes in the Class.
helper context KM3!Class
def : IAN() : Integer =
	self.allInheritedAttributes->size();
--@end helper IAN

--@begin helper AAN
--@comments Available Attributes Number
--@comments Number of Attributes in the Class.
helper context KM3!Class
def : AAN() : Integer =
	self.allAttributes->size();
--@end helper AAN

--@begin helper NRN
--@comments New References Number
--@comments Number of new References in the Class.
helper context KM3!Class
def : NRN() : Integer =
	self.newReferences->size();
--@end helper NRN

--@begin helper IRN
--@comments Inherited References Number
--@comments Number of inherited References in the Class.
helper context KM3!Class
def : IRN() : Integer =
	self.allInheritedReferences->size();
--@end helper IRN

--@begin helper ARN
--@comments Available References Number
--@comments Number of References in the Class.
helper context KM3!Class
def : ARN() : Integer =
	self.allReferences->size();
--@end helper ARN

--@begin helper CHIN
--@comments CHIldren Number
--@comments Number of directly derived Classes.
helper context KM3!Class
def : CHIN() : Integer =
	self.children->size();
--@end helper CHIN

--@begin helper DESN
--@comments DEScendants Number
--@comments Number of all derived Classes (both directly and indirectly).
helper context KM3!Class
def : DESN() : Integer =
	self.descendants->size();
--@end helper DESN

--@begin helper PARN
--@comments PARents Number
--@comments Number of Classes from which the current Class derives directly.
helper context KM3!Class
def : PARN() : Integer =
	self.parents->size();
--@end helper PARN

--@begin helper ASCN
--@comments ASCendants Number
--@comments Number of Classes from which the current Class derives (both directly and indirectly).
helper context KM3!Class
def : ASCN() : Integer =
	self.ascendants->size();
--@end helper ASCN

--@begin helper isInternal
--@comments Indicates if the Class received as parameter belongs to the considered Package.
helper context KM3!Package
def : isInternal(c : KM3!Class) : Boolean =
	self.contents->includes(c);
--@end helper isInternal

--@begin helper baseClasses
--@comments Set of base Classes (from the current Package) that belong to the Package "p".
helper context KM3!Package
def : baseClasses(p : KM3!Package) : Set(KM3!Class) =
	self.internalBaseClasses->select(c|p.isInternal(c))->asSet();
--@end helper baseClasses

--@begin helper baseClassesInPackages
--@comments Set of base Classes in both the current Package and the one bound to the parameter.
helper context KM3!Package
def : baseClassesInPackages(p : KM3!Package) : Set(KM3!Class) =
	self.internalBaseClasses->union(p.internalBaseClasses);
--@end helper baseClassesInPackages

--@begin helper supplierClasses
--@comments Set of supplier Classes (from the current Package) that belong to the Package "p"(excludes inheritance).
helper context KM3!Package
def : supplierClasses(p : KM3!Package) : Set(KM3!Class) =
	self.allClasses->iterate(c; acc : Set(KM3!Class)= Set{}|
		acc->union(c.coupledClasses))->select(c|p.isInternal(c))->asSet();
--@end helper supplierClasses

--@begin helper supplierClassesInPackages
--@comments Set of supplier Classes in both the current Package and the one bound to the parameter.
helper context KM3!Package
def : supplierClassesInPackages(p : KM3!Package) : Set(KM3!Class) =
	self.internalSupplierClasses->union(p.internalSupplierClasses);
--@end helper supplierClassesInPackages

--@begin helper relatedClasses
--@comments Set of Classes from the "p" Package that are either base or supplier Classes.
helper context KM3!Package
def : relatedClasses(p : KM3!Package) : Set(KM3!Class) =
	self.baseClasses(p)->union(self.supplierClasses(p));
--@end helper relatedClasses

--@begin helper CN
--@comments Classes Number
--@comments Number of Classes in the Package.
helper context KM3!Package
def : CN() : Integer =
	self.allClasses->size();
--@end helper CN

--@begin helper PNAN
--@comments Package New Attributes Number
--@comments Number of new Attributes in the Package.
helper context KM3!Package
def : PNAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.NAN());
--@end helper PNAN

--@begin helper PIAN
--@comments Package Inherited Attributes Number
--@comments Number of Attributes inherited in the Package.
helper context KM3!Package
def : PIAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.IAN());
--@end helper PIAN

--@begin helper PAAN
--@comments Package Available Attributes Number
--@comments Number of available Attributes in the Package.
helper context KM3!Package
def : PAAN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.AAN());
--@end helper PAAN

--@begin helper PNRN
--@comments Package New References Number
--@comments Number of new References in the Package.
helper context KM3!Package
def : PNRN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.NRN());
--@end helper PNRN

--@begin helper PIRN
--@comments Package Inherited References Number
--@comments Number of inherited References in the Package.
helper context KM3!Package
def : PIRN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.IRN());
--@end helper PIRN

--@begin helper PARN
--@comments Package Available References Number
--@comments Number of available References in the Package.
helper context KM3!Package
def : PARN() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|acc + c.ARN());
--@end helper PARN

--@begin helper EILN
--@comments External Inheritance Links Number
--@comments Number of inheritance relations where the derived Classes belong to the current Package and the base ones belong to the Package "p" given as parameter.
helper context KM3!Package
def : EILN(p : KM3!Package) : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		acc + c.parents->select(g|p.isInternal(g))->size());
--@end helper EILN

--@begin attribute helper IILN
--@comments Internal Inheritance Links Number
--@comments Number of inheritance relations where the base and derived Classes belong to the current Package.
helper context KM3!Package
def : IILN : Integer =
    self.allClasses->iterate(c; acc : Integer = 0|
        acc + c.parents->select(g|self.isInternal(g))->size());
--@end attribute helper IILN

--@begin helper PILN
--@comments Packages Inheritance Links Number
--@comments Number of inheritance relations between the current package and the one received as parameter.
helper context KM3!Package
def : PILN(p : KM3!Package) : Integer =
	self.IILN + self.EILN(p);
--@end helper PILN

--@begin helper ECLN
--@comments External Coupling Links Number
--@comments Number of coupling relations where the client Class belongs to the current Package and the supplier Class belongs to the Package "p" (excludes inheritance).
helper context KM3!Package
def : ECLN(p : KM3!Package) : Integer =
	self.supplierClassesInPackages(p)->size();
--@end helper ECLN

--@begin helper ICLN
--@comments Internal Coupling Links Number
--@comments Number of distinct coupling relations where both the client and the supplier Classes belong to the current Package (excludes inheritance).
helper context KM3!Package
def : ICLN() : Integer =
	self.internalSupplierClasses->size();
--@end helper ICLN

--@begin helper PCLN
--@comments Packages Coupling Links Number
--@comments Number of coupling relations between the current package and the one received as parameter.
helper context KM3!Package
def : PCLN(p : KM3!Package) : Integer =
	self.ICLN() + self.ECLN(p);
--@end helper PCLN


-------------------------------------------------------


-- uses MOOD4KM3;
-- ============================================================
-- MOOD and MOOD2 Metrics : Intra-Specification Level Metrics =
-- ============================================================

--@begin helper MOOD::AIF
--@comments Attributes Inheritance Factor
--@comments Quotient between the number of inherited Attributes in all Classes of the Package and the number of available Attributes (locally defined plus inherited) for all Classes of the current Package.
--@comments The pre-condition states that the package must have available Attributes.
--@comments AIF() = 0 means that there is no effective Attribute inheritance (either there are no inheritance hierarchies or all inherited Attributes are redefined).
helper context KM3!Package
def : AIF() : Real =
	if self.PAAN() > 0
		then self.PIAN() / self.PAAN()
		else 0
	endif;
--@end helper MOOD::AIF

--@begin helper MOOD::RIF
--@comments References Inheritance Factor
--@comments Quotient between the number of inherited References in all Classes of the Package and the number of available References (locally defined plus inherited) for all Classes of the current Package.
--@comments The pre-condition states that the package must have available References.
--@comments RIF() = 0 means that there is no effective Reference inheritance (either there are no inheritance hierarchies or all inherited References are redefined).
helper context KM3!Package
def : RIF() : Real =
	if self.PARN() > 0
		then self.PIRN() / self.PARN()
		else 0
	endif;
--@end helper MOOD::RIF

--@begin helper MOOD2::IIF
--@comments Internal Inheritance Factor
--@comments Quotient between the number of inheritance links where both the base and derived Classes belong to the current Package and the total number of inheritance links originating in the current Package.
--@comments The pre-condition states that the package must have some inheritance links defined on it.
--@comments Inheritance links originating in the current package are those where the derived Class belongs to it.
--@comments The inheritance link is directed from the derived Class to the base one.
helper context KM3!Package
def : IIF() : Real =
	if self.IILN > 0
		then self.IILN / self.PILN(self)
		else 0
	endif;
--@end helper MOOD2::IIF

--@begin helper MOOD::CCF
--@comments Parametric Polymorphism Factor
--@comments Quotient between the actual number of coupled class-pairs within the Package and the maximum possible number of class-pair couplings in the Package. This coupling is the one not imputable to inheritance.
--@comments In a coupled class-pair one Class is the client and the other is the supplier.
--@comments These clientsupplier relations can have several shapes; see the function Classifier::CoupledClasses for details.
--@comments The pre-condition states that, with only one Class, there are no couplings within the package.
--@comments The square root counteracts for the fact that the couplings grow quadratically with the number of Classes.
helper context KM3!Package
def : CCF() : Real =
	if self.CN() > 1
		then (self.ICLN() / (self.CN() * self.CN() - self.CN())).sqrt()
		else 0
	endif;
--@end helper MOOD::CCF

--@begin helper MOOD::ICF
--@comments Internal Coupling Factor
--@comments Quotient between the number of coupling links where both the client and supplier Classes belong to the current Package and the total number of coupling links originating in the current Package.
--@comments Coupling links originating in the current Package are those where the client Class belongs to it.
--@comments The coupling link is directed from the client Class to the supplier one.
helper context KM3!Package
def : ICF() : Real =
	if self.ICLN() > 0
		then self.ICLN() / self.PCLN(self)
		else 0
	endif;
--@end helper MOOD::ICF

-------------------------------------------

--uses EMOOSE4KM3;
-- ===============
-- MOOSE Metrics =
-- ===============

--@begin helper MOOSE::WRC
--@comments Weighted References per Class
--@comments The sum of complexities of the References in the current Class. If all method complexities are considered to be unique, WRC is equal to the number of References.
--@comments The authors do not propose any algorithm for calculating the complexities of methods.
--@comments As such, in the formalization above, the complexities were considered unitary.
helper context KM3!Classifier
def : WRC() : Integer =
	self.allReferences->size();
--@end helper MOOSE::WRC

--@begin helper MOOSE::DIT
--@comments Depth of Inheritance Tree
--@comments The length of the longest path of inheritance from the current Class to the root of the tree.
helper context KM3!Classifier
def : DIT() : Integer =
	if self.isRoot
		then 0
		else if self.PARN() = 1
				then 1
				else 0
			endif + self.parents->iterate(c; acc : Integer = 0|acc + c.DIT())
	endif;
--@end helper MOOSE::DIT

--@begin helper MOOSE::NOC
--@comments Number of Children
--@comments The number of classes that inherit directly from the current Class.
helper context KM3!Classifier
def : NOC() : Integer =
	self.CHIN();
--@end helper MOOSE::NOC

--@begin helper MOOSE::CBO
--@comments Coupling Between Objects
--@comments The number of other Classes that are coupled to the current one. Two Classes are coupled when methods declared in one Class use References or instance variables defined by the other Class.
helper context KM3!Classifier
def : CBO() : Integer =
	self.coupledClasses->size();
--@end helper MOOSE::CBO


-- ================
-- EMOOSE Metrics =
-- ================

--@begin helper EMOOSE::SIZE2
--@comments Number of local Attributes and References (only the containment ones) defined in the Class.
helper context KM3!Classifier
def : SIZE2() : Integer =
	self.NRN() + self.NAN();
--@end helper EMOOSE::SIZE2



-- uses QMOOD4KM3;
-- ===============
-- QMOOD Metrics =
-- ===============

--@begin helper QMOOD::DSC
--@comments Design Size in Classes
--@comments Count of the total number of Classes in the design.
helper context KM3!Package
def : DSC() : Integer =
	self.CN();
--@end helper QMOOD::DSC

--@begin helper QMOOD::NOH
--@comments Number of Hierarchies
--@comments Count of the number of Class hierarchies in the design.
--@comments In [Abreu et al., 2000], this metric has another interpretation.
--@comments  There, hierarchies are not the number of inheritance relations but the number of inheritance trees.
--@comments  In this case, this metric is always equal to 1 for systems developed in languages that have a common super class (like Object in Smalltalk and Java).
--@comments  This case shows that the metric is centered in the language, which is considered as a potential problem (Remember QMOOD metrics were created based upon C++). 
helper context KM3!Package
def : NOH() : Integer =
	self.allClasses->collect(c|c.children)->flatten()->asSet()->size();
--@end helper QMOOD::NOH

--@begin helper QMOOD::NIC
--@comments Number of Independent Classes
--@comments Count of the number of Classes that are not inherited by any Class in the design.
helper context KM3!Package
def : NIC() : Integer =
	self.allClasses->select(c|c.isLeaf)->size();
--@end helper QMOOD::NIC

--@begin helper QMOOD::NSI
--@comments Number of Single Inheritance
--@comments Number of Classes (sub classes) that use inheritance in the design.
--@comments According to [Abreu et al., 2000], for the same reason than in NOH, this metric would be always equal to DSC (if the Classes belonging to the development environment were considered) or to DSC â€“ 1 (in the opposite case).
--@comments This is another signal of language dependency.
helper context KM3!Package
def : NSI() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		if c.PARN() = 1
			then acc + 1
			else acc
		endif);
--@end helper QMOOD::NSI

--@begin helper QMOOD::NMI
--@comments Number of Multiple Inheritance
--@comments Count of the number of instances of multiple inheritance in the design.
--@comments [Abreu et al., 2000] say that for languages as Smalltalk or Delphi, which do not support multiple inheritance, this metric is always equal to zero.
--@comments This interpretation is a clear signal of ill definition of the metric.
helper context KM3!Package
def : NMI() : Integer =
	self.allClasses->iterate(c; acc : Integer = 0|
		if c.PARN() > 1
			then acc + 1
			else acc
		endif);
--@end helper QMOOD::NMI

--@begin helper QMOOD::NNC
--@comments Number of Internal Classes
--@comments Count of the number of internal Classes defined for creating generalization-specialization structures in Class hierarchies of the design.
--@comments In this case, why to have the same value than NOH? Has this metric another interpretation? [Abreu et al., 2000] say that this metric is always equal to DSC or DSC -1, by the reasons pointed out in NOH and NSI.
helper context KM3!Package
def : NNC() : Integer =
	self.NOH();
--@end helper QMOOD::NNC

--@begin helper QMOOD::NAC
--@comments Number of Abstract Classes
--@comments Count of the number of Classes that have been defined purely for organizing information in the design.
helper context KM3!Package
def : NAC() : Integer =
	self.allClasses->select(c|c.isAbstract)->size();
--@end helper QMOOD::NAC

--@begin helper QMOOD::NLC
--@comments Number of Leaf Classes
--@comments Count of the number of leaf Classes in the hierarchies of the design.
--@comments This metric is the same than NIC, defined above.
helper context KM3!Package
def : NLC() : Integer =
	self.allClasses->select(c|c.isLeaf)->size();
--@end helper QMOOD::NLC

--@begin helper QMOOD::ADI
--@comments Average Depth of Inheritance
--@comments The average depth of inheritance of Classes in the design. It is computed by dividing the summation of maximum path lengths to all Classes by the number of Classes. The path length for a Class is the number of edges from the root to the Class in an inheritance tree representation. 
helper context KM3!Package
def : ADI() : Real =
	self.allClasses->iterate(c; acc : Real = 0|(acc + c.DIT()) / self.CN());
--@end helper QMOOD::ADI

--@begin helper QMOOD::AWI
--@comments Average Width of Inheritance
--@comments The average number of children per Class in the design. The metric is computed by dividing the summation of the number of children over all Classes by the number of Classes in the design.
--@comments Accordingly to a different view point, [Abreu et al., 2000] say this metric is always equal to DSC or DSC - 1, when multiple inheritance is not supported by the language, as in Smalltalk, Eiffel or Java. The same happens with NOH, NSI and NNC.
helper context KM3!Package
def : AWI() : Real =
	self.allClasses->iterate(c; acc : Real = 0|(acc + c.CHIN()) / self.CN());
--@end helper QMOOD::AWI

--@begin helper QMOOD::ANA
--@comments Average Number of Ancestors
--@comments The average number of Classes from which a class inherits information.
--@comments This metric is similar to the ADI measure and differs only when there are instances of multiple inheritance in the design.
helper context KM3!Package
def : ANA() : Real =
	if self.CN() > 0
		then self.internalBaseClasses->size() / self.CN()
		else 0
	endif;
--@end helper QMOOD::ANA

--@begin helper QMOOD::MAA
--@comments Measure of Attribute Abstraction
--@comments The ratio of the number of Attributes inherited by a Class to the total number of Attributes in the Class.
--@comments In order to calculate MAA, number of attributes must be greater than zero.
helper context KM3!Classifier
def : MAA() : Integer =
	let nbFCV : Integer =
		self.allAttributes->iterate(a; acc : Integer = 0|
			if self.FCV(a)
				then acc + 1
				else acc
			endif) in
	if nbFCV > 0
		then self.IAN() / nbFCV
		else 0
	endif;
--@end helper QMOOD::MAA

--@begin helper QMOOD::MRA
--@comments Measure of Reference Abstraction
--@comments The ratio of the number of References inherited by a Class to the total number of References in the Class.
--@comments In order to calculate MRA, number of references must be greater than zero.
helper context KM3!Classifier
def : MRA() : Integer =
	let nbFCV : Integer =
		self.allReferences->iterate(r; acc : Integer = 0|
			if self.FCV(r)
				then acc + 1
				else acc
			endif) in
	if nbFCV > 0
		then self.IRN() / nbFCV
		else 0
	endif;
--@end helper QMOOD::MRA

--@begin helper QMOOD::MOA
--@comments Measure of Aggregation
--@comments Count of the number of data declarations whose types are user defined Classes.
helper context KM3!Classifier
def : MOA() : Integer =
	let owner : KM3!Package = self.package in
	if not owner.oclIsUndefined()
		then self.allFeatures->iterate(f; acc: Integer = 0|
			if owner.allClasses->includes(f.type)
				then acc + 1
				else acc
			endif)
		else 0
	endif;
--@end helper QMOOD::MOA

--@begin helper QMOOD::MRM
--@comments Modeled Relationship Measure
--@comments Measure of the total number of Attribute and Parameter based relationships in a Class.
helper context KM3!Classifier
def : MRM() : Integer =
	self.DCC() + self.NAD();
--@end helper QMOOD::MRM

--@begin helper QMOOD::NOA
--@comments Number of Ancestors
--@comments Counts the number of distinct Classes which a Class inherits.
helper context KM3!Classifier
def : NOA() : Integer =
	self.ASCN();
--@end helper QMOOD::NOA

--@begin helper QMOOD::NOR
--@comments Number of References
--@comments Count of all the References defined in a Class.
helper context KM3!Classifier
def : NOR() : Integer =
	self.ARN();
--@end helper QMOOD::NOR

--@begin helper QMOOD::NOD
--@comments Number of Attributes
--@comments Number of Attributes in the Class.
helper context KM3!Classifier
def : NOD() : Integer =
	self.AAN();
--@end helper QMOOD::NOD

--@begin helper QMOOD::NAD
--@comments Number of Abstract Data Types
--@comments Number of user defined objects (ADTs) used as Features in the Class and which are necessary to instantiate an object instance of the (aggregate) Class.
helper context KM3!Classifier
def : NAD() : Integer =
	self.allFeatures->collect(f|f.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->asSet()->size();
--@end helper QMOOD::NAD

--@begin helper QMOOD::CSM
--@comments Class Size Metric
--@comments Sum of the number of References and Attributes in the Class.
helper context KM3!Classifier
def : CSM() : Integer =
	self.AAN() + self.ARN();
--@end helper QMOOD::CSM

--@begin helper QMOOD::DCC
--@comments Direct Class Coupling
--@comments Count of the different number of Classes that a Class is directly related to. The metric includes Classes that are directly related by Attribute and References declarations.
helper context KM3!Classifier
def : DCC() : Integer =
	self.allFeatures->collect(f|f.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->asSet()->size();
--@end helper QMOOD::DCC

--@begin helper QMOOD::MCC
--@comments Maximum Class Coupling
--@comments This metric not only includes Classes that are directly related to a Class by Attributes and References, but also Classes that are indirectly related through the directly related Classes.
helper context KM3!Classifier
def : MCC() : Integer =
	self.allFeatures->collect(f|f.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->
				iterate(t; acc : Sequence(KM3!Classifier) = Sequence{}|
					acc->union(t.allFeatures->collect(f|f.type)))->
						reject(c|c.oclIsKindOf(KM3!DataType))->asSet()->size();
--@end helper QMOOD::MCC

--@begin helper QMOOD::DAC
--@comments Direct Attribute Based Coupling
--@comments This metric is a direct count of the number of different Class types that are declared as Attribute references inside a Class.
helper context KM3!Classifier
def : DAC() : Integer =
	self.allAttributes->collect(a|a.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->asSet()->size();
--@end helper QMOOD::DAC

--@begin helper QMOOD::DRC
--@comments Direct Reference Based Coupling
--@comments This metric is a direct count of the number of different Class types that are declared as Reference inside a Class.
helper context KM3!Classifier
def : DRC() : Integer =
	self.allReferences->collect(a|a.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->asSet()->size();
--@end helper QMOOD::DRC

--@begin helper QMOOD::CCD
--@comments Class Complexity Based on Data
--@comments Computes complexity based upon the number of components (Attributes) that are defined in the Class.
--@comments All component declarations are resolved to the basic primitives (integers, doubles and characters).
--@comments The metric value is a count of the number of primitives.
helper context KM3!Classifier
def : CCD() : Integer =
	self.AAN() + (self.allAttributes->
		collect(a|a.type)->
		reject(c|c.oclIsKindOf(KM3!DataType))->
			reject(c|c.oclIsKindOf(KM3!Enumeration))->
				iterate(t; acc : Integer = 0|acc + t.AAN()));
--@end helper QMOOD::CCD

----------------

--@begin attribute helpers measureLevel
--@comments Defines the measure level among {#package,#class}. 
--@comments The package level allows measures on packages.
--@comments The class level allows measures on packages and classes.
helper def : measureLevel : Measure!ElementKind = #class;
--@end attribute helper measureLevel

--@begin attribute helper root
--@comments The root measure set.
helper def : root : Measure!RootMeasureSet = OclUndefined;
--@end attribute helper root

--@begin attribute helper MetricByName
--@comments The map of metrics by name.
helper def : MetricByName : Map(String, Measure!Metric) = Map{};
--@end attribute helper MetricByName

--@begin entrypoint rule Metrics
--@comments Registers the MOOD, MOOD2, MOOSE, EMOOSE and QMOOD metrics implemented in libraries.
entrypoint rule Metrics() {
	to
		root : Measure!RootMeasureSet (
			modelType <- #KM3
		)
	do {
		thisModule.root <- root;
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			root.categories <-
				thisModule.Category('MOOD','Metrics for Object-Oriented Design');
			thisModule.Metric('MOOD','AIF','Attributes Inheritance Factor');
			thisModule.Metric('MOOD','RIF','References Inheritance Factor');
			thisModule.Metric('MOOD','CCF','Class Coupling Factor');
			thisModule.Metric('MOOD','ICF','Internal Coupling Factor');
				
			-- ===================================================
			-- MOOD2 Metrics : Intra-Specification Level Metrics =
			-- ===================================================
			root.categories <-
				thisModule.Category('MOOD2',
					'Metrics for Object-Oriented Design 2');
			thisModule.Metric('MOOD2','IIF','Internal Inheritance Factor');
		}
		
		if (thisModule.measureLevel = #class) {
			-- ===============
			-- MOOSE Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('MOOSE',
				'Metrics for Object-Oriented Software Engineering');
			thisModule.Metric('MOOSE','WRC','Weighted References per Class');
			thisModule.Metric('MOOSE','DIT','Depth of Inheritance Tree');
			thisModule.Metric('MOOSE','NOC','Number of Children');
			thisModule.Metric('MOOSE','CBO','Coupling Between Objects');
		
			-- ================
			-- EMOOSE Metrics =
			-- ================
			root.categories <-
				thisModule.Category('EMOOSE','Extended MOOSE');
			thisModule.Metric('EMOOSE','SIZE2','Number of local Attributes ' +
				'and References defined in the Class');
		}
		
		if ((thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)) {
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			root.categories <-
				thisModule.Category('QMOOD',
				'Quality Model for Object-Oriented Design');		
			thisModule.Metric('QMOOD','DSC','Design Size in Classes');
			thisModule.Metric('QMOOD','NOH','Number of Hierarchies');
			thisModule.Metric('QMOOD','NIC','Number of Independent Classes');
			thisModule.Metric('QMOOD','NSI','Number of Single Inheritance');
			thisModule.Metric('QMOOD','NMI','Number of Multiple Inheritance');
			thisModule.Metric('QMOOD','NNC','Number of Internal Classes');
			thisModule.Metric('QMOOD','NAC','Number of Abstract Classes');
			thisModule.Metric('QMOOD','NLC','Number of Leaf Classes');
			thisModule.Metric('QMOOD','ADI','Average Depth of Inheritance');
			thisModule.Metric('QMOOD','AWI','Average Width of Inheritance');
			thisModule.Metric('QMOOD','ANA','Average Number of Ancestors');
		}
			
		if (thisModule.measureLevel = #class) {			
			thisModule.Metric('QMOOD','MAA','Measure of Attribute Abstraction');
			thisModule.Metric('QMOOD','MRA','Measure of Reference Abstraction');
			thisModule.Metric('QMOOD','MOA','Measure of Aggregation');
			thisModule.Metric('QMOOD','MRM','Modeled Relationship Measure');
			thisModule.Metric('QMOOD','NOA','Number of Ancestors');
			thisModule.Metric('QMOOD','NOR','Number of References');
			thisModule.Metric('QMOOD','NOD','Number of Attributes');
			thisModule.Metric('QMOOD','NAD','Number of Abstract Data Types');
			thisModule.Metric('QMOOD','CSM','Class Size Metric');
			thisModule.Metric('QMOOD','DCC','Direct Class Coupling');
			thisModule.Metric('QMOOD','MCC','Maximum Class Coupling');
			thisModule.Metric('QMOOD','DAC','Direct Attribute Based Coupling');
			thisModule.Metric('QMOOD','DRC','Direct Reference Based Coupling');
			thisModule.Metric('QMOOD','CCD','Class Complexity Based on Data');
		}
	}
}
--@end entrypoint rule Metrics

--@begin rule Package2MeasureSet
--@comments Collects measurement data on a package (measureLevel must be set to #package or #class).
rule Package2MeasureSet {
	from
		ne : KM3!Package (
			(thisModule.measureLevel = #package) or
			(thisModule.measureLevel = #class)
		)
	to
		ms : Measure!MeasureSet (
			elementName <-
				if ne.CN() > 0
					then ne.name.debug('Processing metrics on package')
					else ne.name
				endif,
	   		elementType <- #package,
			subsets <- ne.contents
		)
	do {
		if (ne.package.oclIsUndefined()) {
			thisModule.root.measureSets <- ms;
		}
		
		if (ne.CN() > 0) {
			-- ==================================================
			-- MOOD Metrics : Intra-Specification Level Metrics =
			-- ==================================================
			ms.measures <- thisModule.PercentageMeasure('AIF',ne.AIF());
			ms.measures <- thisModule.PercentageMeasure('RIF',ne.RIF());
			ms.measures <- thisModule.PercentageMeasure('CCF',ne.CCF());
			ms.measures <- thisModule.PercentageMeasure('ICF',ne.ICF());
				
			-- =============================================================
			-- MOOD2 Metrics : Intra and Inter-Specification Level Metrics =
			-- =============================================================
			ms.measures <- thisModule.PercentageMeasure('IIF',ne.IIF());
		
			-- ===============
			-- QMOOD Metrics =
			-- ===============
			ms.measures <- thisModule.IntegerMeasure('DSC',ne.DSC());
			ms.measures <- thisModule.IntegerMeasure('NOH',ne.NOH());
			ms.measures <- thisModule.IntegerMeasure('NIC',ne.NIC());
			ms.measures <- thisModule.IntegerMeasure('NSI',ne.NSI());
			ms.measures <- thisModule.IntegerMeasure('NMI',ne.NMI());
			ms.measures <- thisModule.IntegerMeasure('NNC',ne.NNC());
			ms.measures <- thisModule.IntegerMeasure('NAC',ne.NAC());
			ms.measures <- thisModule.IntegerMeasure('NLC',ne.NLC());
			ms.measures <- thisModule.DoubleMeasure('ADI',ne.ADI());
			ms.measures <- thisModule.DoubleMeasure('AWI',ne.AWI());
			ms.measures <- thisModule.DoubleMeasure('ANA',ne.ANA());
		}
	}
}
--@end rule Package2MeasureSet

--@begin rule Class2MeasureSet
--@comments Collects measurement data on a class (measureLevel must be set to #class).
rule Class2MeasureSet {
	from
		ne : KM3!Class (
			thisModule.measureLevel = #class
		)
	to
		ms : Measure!MeasureSet (
			elementName <- ne.name.debug('Processing metrics on class'),
	   		elementType <- #class
		)
	do {
		-- ===============
		-- MOOSE Metrics =
		-- ===============
		ms.measures <- thisModule.IntegerMeasure('WRC',ne.WRC());
		ms.measures <- thisModule.IntegerMeasure('DIT',ne.DIT());
		ms.measures <- thisModule.IntegerMeasure('NOC',ne.NOC());
		ms.measures <- thisModule.IntegerMeasure('CBO',ne.CBO());
	
		-- ================
		-- EMOOSE Metrics =
		-- ================
		ms.measures <- thisModule.IntegerMeasure('SIZE2',ne.SIZE2());
	
		-- ===============
		-- QMOOD Metrics =
		-- ===============
		ms.measures <- thisModule.PercentageMeasure('MAA',ne.MAA());
		ms.measures <- thisModule.PercentageMeasure('MRA',ne.MRA());
		ms.measures <- thisModule.IntegerMeasure('MOA',ne.MOA());
		ms.measures <- thisModule.IntegerMeasure('MRM',ne.MRM());
		ms.measures <- thisModule.IntegerMeasure('NOA',ne.NOA());
		ms.measures <- thisModule.IntegerMeasure('NOR',ne.NOR());
		ms.measures <- thisModule.IntegerMeasure('NOD',ne.NOD());
		ms.measures <- thisModule.IntegerMeasure('NAD',ne.NAD());
		ms.measures <- thisModule.IntegerMeasure('CSM',ne.CSM());
		ms.measures <- thisModule.IntegerMeasure('DCC',ne.DCC());
		ms.measures <- thisModule.IntegerMeasure('MCC',ne.MCC());
		ms.measures <- thisModule.IntegerMeasure('DAC',ne.DAC());
		ms.measures <- thisModule.IntegerMeasure('DRC',ne.DRC());
		ms.measures <- thisModule.IntegerMeasure('CCD',ne.CCD());
	}
}
--@end rule Class2MeasureSet
		
--@begin called rule Category
--@comments Creates a category for metric classification with a name and a description.
rule Category(name : String, desc : String) {
	to
		cat : Measure!Category (
			name <- name,
			desc <- desc
		)
	do {
		cat;
	}
}
--@end called rule Category
		
--@begin called rule Metric
--@comments Creates a metric for a category with a name and a description (the default preferred value for the metric is set to not equal to zero ['!=0']).
rule Metric(catName : String, name : String, desc : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- '!=0',
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule Metric
		
--@begin called rule MetricWithPreferredValue
--@comments Creates a metric for a category with a name, a description and a preferred value for the metric (an operator [<, <=, =, !=, >=, >] followed by a number).
rule MetricWithPreferredValue(catName : String, name : String, desc : String, preferredValue : String) {
	to
		metric : Measure!Metric (
			name <- name,
			desc <- desc,
			preferredValue <- preferredValue,
			category <- thisModule.root.categories->
				select(cat|cat.name = catName)->first()
		)
	do {
		thisModule.MetricByName <-
			thisModule.MetricByName.including(metric.name,metric);
	}
}
--@end called rule MetricWithPreferredValue
		
--@begin called rule IntegerMeasure
--@comments Stores an Integer measure for the metric which name and value are given.
rule IntegerMeasure(name : String, value : Integer) {
	to
		meas : Measure!IntegerMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule IntegerMeasure
		
--@begin called rule DoubleMeasure
--@comments Stores a Double measure for the metric which name and value are given.
rule DoubleMeasure(name : String, value : Real) {
	to
		meas : Measure!DoubleMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule DoubleMeasure
		
--@begin called rule PercentageMeasure
--@comments Stores a Percentage measure for the metric which name and value are given.
rule PercentageMeasure(name : String, value : Real) {
	to
		meas : Measure!PercentageMeasure (
			metric <- thisModule.MetricByName.get(name),
			value <- value
		)
	do {
		meas;
	}
}
--@end called rule PercentageMeasure