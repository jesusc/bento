--
-- Written in January and in February 2005 by Peter Rosenthal
--

module GeometricalTransformations;

create OUT : DXF2 from IN1 : DXF1, IN2 : GeoTrans;

-- uses GeometryLib;
helper def: PIDiv180 : Real = 0.017453292519943295769236907684886;
	
helper def : rotate( rotationAngle : TupleType(x : Real, y : Real, z : Real),
					pointOfOrigin : TupleType(x : Real, y : Real, z : Real), 
					rotationPoint : TupleType(x : Real, y : Real, z : Real))
					: TupleType(x : Real, y : Real, z : Real) =
	
	let rotationPointO : TupleType(x : Real, y : Real, z : Real) = 
		rotationPoint in
--		thisModule.moveBackward(rotationPoint, pointOfOrigin ) in
	let XRadAng : Real = rotationAngle.x * thisModule.PIDiv180 in
	let YRadAng : Real = rotationAngle.y * thisModule.PIDiv180 in
	let ZRadAng : Real = rotationAngle.z * thisModule.PIDiv180 in
  
	let SinX : Real = XRadAng.sin() in
	let SinY : Real = YRadAng.sin() in
	let SinZ : Real = ZRadAng.sin() in

	let CosX : Real = XRadAng.cos() in
	let CosY : Real = YRadAng.cos() in
	let CosZ : Real = ZRadAng.cos() in

	let TempY : Real = rotationPointO.y * CosY - rotationPointO.z * SinY in
	let TempZ : Real = rotationPointO.y * SinY + rotationPointO.z * CosY in
	let TempX : Real = rotationPointO.x * CosX - TempZ * SinX in

	let Nz : Real = rotationPointO.x * SinX + TempZ * CosX in
	let Nx : Real = TempX * CosZ - TempY * SinZ in
	let Ny : Real = TempX * SinZ + TempY * CosZ in
 
	let rotated : TupleType(x : Real, y : Real, z : Real) = 
		Tuple {x = Nx, y = Ny, z = Nz} in
--		thisModule.moveForward(Tuple {x = Nx, y = Ny, z = Nz}, pointOfOrigin) in
	rotated;


helper def : moveForward(	a : TupleType(x : Real, y : Real, z : Real),
				 		b : TupleType(x : Real, y : Real, z : Real)) :
				 	 		TupleType(x : Real, y : Real, z : Real) =

	Tuple {
		x = a.x + b.x,
		y = a.y + b.y,
		z = a.z + b.z
	};

helper def : moveBackward(	a : TupleType(x : Real, y : Real, z : Real),
				 	b : TupleType(x : Real, y : Real, z : Real)) :
				 		TupleType(x : Real, y : Real, z : Real) =

	Tuple {
		x = a.x - b.x,
		y = a.y - b.y,
		z = a.z - b.z
	};	

helper def: sign(s : Real): Real =	-- returns absolute value
	if ( s < 0.0) then 
		0-1.0 
	else
		1.0
	endif;

helper def : explode( explosionFactor : Real, e : TupleType(x : Real, y : Real, z : Real) ) : TupleType(x : Real, y : Real, z : Real) =
	Tuple {
		x = e.x * (1 + explosionFactor / ( e.x +  thisModule.sign(e.x)) * thisModule.sign(e.x)),
		y = e.y * (1 + explosionFactor / ( e.y +  thisModule.sign(e.y)) * thisModule.sign(e.y)),		
		z = e.z * (1 + explosionFactor / ( e.z +  thisModule.sign(e.z)) * thisModule.sign(e.z))	
	};

-- Regular transformation begins here


helper  def : getRealParam( command : GeoTrans!GeoTransfo , paramName : String ) : Real =
	if (command.params->select(c | c.name = paramName)->size()=0) then
		0.0
	else
		(command.params->select(c | c.name = paramName)->first()).param
	endif;

-- calculates the gravity center (=average) of all points of a mesh
helper  def: getNewGC(s : DXF1!Mesh) : TupleType(x : Real, y : Real, z : Real) =
	let nbPoints : Integer = s.points->size() in
	Tuple {
		x = s.points->iterate(e; acc : Real = 0.0 | acc + e.x) / nbPoints,
		y = s.points->iterate(e; acc : Real = 0.0 | acc + e.y) / nbPoints,
		z = s.points->iterate(e; acc : Real = 0.0 | acc + e.z) / nbPoints
	};

helper def : execute( point : DXF1!Point, -- calculatedSoFar
					  a : TupleType(x : Real, y : Real, z : Real), 
					  command : GeoTrans!GeoTransfo) : 
					TupleType(x : Real, y : Real, z : Real) =

	if (command.name='explode') then -- false: explode has to be run as rotate
		let p : Real = thisModule.getRealParam(command, 'factor') in 
			thisModule.explode( p , a )
	else
		if (command.name='rotate') then
			let rotationAngle : TupleType(x : Real, y : Real, z : Real) = 
				Tuple { x = thisModule.getRealParam(command, 'rotationX'),
						y = thisModule.getRealParam(command, 'rotationY'),
						z = thisModule.getRealParam(command, 'rotationZ')} in 
				thisModule.rotate( rotationAngle , thisModule.getNewGC(point.mesh) , a )
		else
			if (command.name='moveForward') then
				let vector : TupleType(x : Real, y : Real, z : Real) = 
				Tuple { x = thisModule.getRealParam(command, 'x'),
						y = thisModule.getRealParam(command, 'y'),
						z = thisModule.getRealParam(command, 'z')} in 
					thisModule.moveForward( a, vector )
			else
					if (command.name='moveBackward') then
						let vector : TupleType(x : Real, y : Real, z : Real) = 
							Tuple { x = thisModule.getRealParam(command, 'x'),
									y = thisModule.getRealParam(command, 'y'),
									z = thisModule.getRealParam(command, 'z')} in 
							thisModule.moveBackward( a, vector )
					else
						a
					endif
			endif
		endif	
	endif;

helper def : doCommands( a : DXF1!Point,
						 calculated : TupleType(x : Real, y : Real, z : Real), 
						 command : GeoTrans!GeoTransfo) 
						: TupleType(x : Real, y : Real, z : Real) =	
						
	if command.superGeoTransfo.oclIsUndefined() then
		thisModule.execute(a, calculated, command)
	else
		let newlyCalculated :  DXF1!Point	 = 
			thisModule.doCommands(a, calculated, command.superGeoTransfo) in
		thisModule.execute(a,newlyCalculated, command)
	endif;

helper context DXF1!Point def  : getPoint() : 
	TupleType(x : Real, y : Real, z : Real)  =
	
	Tuple { x = self.x,
			y = self.y,
			z = self.z
	};
	
rule DXF2DXF {
	from
		f : DXF1!DXF
	to
		out : DXF2!DXF (
			meshes <- f.meshes
		)
}
	
rule Mesh {
	from
		mesh : DXF1!Mesh
	to 
		out : DXF2!Mesh (
		 	name <- mesh.name,
			points <- mesh.points
		)
}
				
rule Point {
	from
		point :	DXF1!Point
	using {
		c : TupleType(x : Real, y : Real, z : Real) = 
				-- getting the root command g of the geometric transformation commands
				let g : GeoTrans!GeoTransfo = 
					GeoTrans!GeoTransfo->
						allInstances()->
							select(t| t.subGeoTransfos->size() = 0 )->first()
				in 
				-- executing the sequence of geometric transformation commands on this particular point
				-- starting with the root command
					thisModule.doCommands( point, point.getPoint(), g );
	}
	to
		out : DXF2!Point (
		 	name <- point.name,
			x <- c.x,
			y <- c.y,
			z <- c.z				
	)
}

