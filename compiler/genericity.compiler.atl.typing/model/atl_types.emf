@namespace(uri="http://genericity/types/atl", prefix="atl_types")
package atl_types;

//import "http://www.eclipse.org/emf/2002/Ecore";

abstract class Type {
	attr boolean[1] multivalued = false;

    transient attr Object[0..1] metamodelRef;

}

class OclUndefinedType extends Type {
   
}

abstract class PrimitiveType extends Type {
}

class BooleanType extends PrimitiveType {
	ref Metaclass[0..*] kindOfTypes;
}

class IntegerType extends PrimitiveType {
}

class StringType extends PrimitiveType {
}

class FloatType extends PrimitiveType {
}

class TupleType extends Type {
   val TupleAttribute[*] attributes;
}

class MapType extends Type {
   ref Type[1] keyType;
   ref Type[1] valueType;
}

class TupleAttribute {
   attr String[1] name;
   ref Type[1] type;
}

class RefType extends Type {
   
}

class Unknown extends RefType {
   
}

class EmptyCollectionType extends Type {
   
}


class TypeError extends Type {
   
}

class UnresolvedTypeError extends TypeError, Metaclass {
	
}

class UnknownFeature extends ecore.EStructuralFeature {
   ref EClass[1] theContainingClass;
}

class EmptyCollection extends Type {
   
}

/*
class EnumLiteralType extends Type {
   ref EnumType[1] type;
   attr String[1] value;   
}
*/

class EnumType extends Type {
   attr String[1] name;
   ref EObject[1] eenum;      
}

class MetaModel {
   attr String[1] name; 
}

class Metaclass extends RefType {
   attr String[1] name;
   attr boolean explicitOcurrence;
   ref EClass[1] klass;   

   ref MetaModel[1] model;
}

abstract class ReflectiveType extends Type {
   
}

class UnionType extends Type {
	ref Type[*] possibleTypes;   
}

class ThisModuleType extends Type {
   
   
}

/**
 * This is to support oclType()
 */
class ReflectiveClass extends ReflectiveType {
   
}

abstract class CollectionType extends Type {
   ref Type[1] containedType;
}

class SequenceType extends CollectionType {
}

class SetType extends CollectionType {  
}


@namespace(uri="http://genericity/types/atl/annotations", prefix="atl_types_annotations")
package annotations {
  abstract class AtlAnnotation {
	//val AtlAnnotation[*]#parent children;
	//ref AtlAnnotation[0..1]#children parent;
  }

  class TransformationAnn extends AtlAnnotation {
  	 ref EObject[1] module;
  
     val MatchedRuleAnn[*] matchedRules;
     val CalledRuleAnn[*] calledRules;
     val LazyRuleAnn[*] lazyRules;
     
     val HelperAnn[*] helpers;
  }

  abstract class RuleAnn extends AtlAnnotation {
    ref EObject rule;
    
    val OutputPatternAnn[1..*] outputPatterns;

	attr String[1] name;

	//Not added yet because the information is already in the original ATL model
	//ref RuleAnn[0..1]#subRules superRule;
	//ref RuleAnn[*]#superRule subRules;

  }
  
  abstract class MatchedRuleAnn extends RuleAnn {
    val ExpressionAnnotation[0..1] filter;
    ref Metaclass[1] outputPatternType;        
  }
  
  class MatchedRuleOneAnn extends MatchedRuleAnn {
  	ref Metaclass[1] inPatternType;   
  }
  
  class MatchedRuleManyAnn extends MatchedRuleAnn {
  	ref Metaclass[2..*] inPatternTypes;   
  }
  
  abstract class ImperativeRuleAnn extends RuleAnn, ModuleCallableAnn {
     
  }
  
  class LazyRuleAnn extends ImperativeRuleAnn {
  	ref Metaclass[1] inPatternType;   
    ref Metaclass[1] outputPatternType;   
  }
  
  class CalledRuleAnn extends ImperativeRuleAnn {
     
  }
  
  
  class OutputPatternAnn extends RuleAnn {
    ref EObject outputPatternElement;
    ref Type[1] type;

     val BindingAnn[*] bindings;
  }

  // TODO: Distinguish the different kind of helpers
  abstract class HelperAnn extends AtlAnnotation, ModuleCallableAnn {
    ref EObject helper;
	attr String[1] name;
	ref Type[1] returnType;
  	
  	val ExpressionAnnotation[1] expr;
  }

  abstract class ModuleCallableAnn extends AtlAnnotation {
     ref CallExprAnn[*]#staticResolver calledBy;
 
 	 ref Type[*] arguments;
     attr String[*] names; // This is to facilitate OCL generation
 	 ref EObject[*] argumentVars;
  }

  class ModuleHelperAnn extends HelperAnn {
       
  }
  
  class ContextHelperAnn extends HelperAnn {
	ref Type[1] contextType;
	
	ref CallExprAnn[*]#dynamicResolvers polymorphicCalledBy;
  }
  

  class BindingAnn extends AtlAnnotation {
    ref EObject rule;
	ref EObject binding;
	attr String[0..1] name;
	ref Type[1] sourceType;
	ref Type[1] targetType;
	ref EObject[1] writtenFeature;
	
	val ExpressionAnnotation[1] value;
	
	val RuleResolutionInfo[*] resolvedBy;
	
  	ref analysis.ControlFlow[1] controlFlow;
  }

  class RuleResolutionInfo {
	ref MatchedRuleOneAnn[1] rule;
	ref MatchedRuleOneAnn[1..*] allInvolvedRules;  	
  }

  abstract class ExpressionAnnotation extends AtlAnnotation {
    ref EObject expr;
	ref Type[1] type;
	
	// Reference to EStructuralFeature and the type of the static receptor
	ref EObject[0..1] usedFeature;
	ref EObject[0..1] receptorType;	
  }
  
  
  class LetExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[1] init;
     val ExpressionAnnotation[1] body;
  }
  
  class IfExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[1] ifCondition;
     val ExpressionAnnotation[1] thenPart;
     val ExpressionAnnotation[1] elsePart;
     
  }
  
  class CallExprAnn extends ExpressionAnnotation {
  	val ExpressionAnnotation[1] source;
  	val ExpressionAnnotation[*] arguments;  	   

	attr boolean[1] isStaticCall = false;
	ref ModuleCallableAnn[1]#calledBy staticResolver;
	ref ContextHelperAnn[1..*]#polymorphicCalledBy dynamicResolvers;
  }

  abstract class AbstractIteratorExprAnn extends ExpressionAnnotation {
  	val ExpressionAnnotation[1] source;   
 	val ExpressionAnnotation[1] body;    
  }
  
  class IteratorExprAnn extends AbstractIteratorExprAnn {
  }

  class IterateExprAnn extends AbstractIteratorExprAnn {
  	val ExpressionAnnotation[1] resultVar;   
  }

  class CollectionExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] initializers;
  }

  class MapExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] keyInitializers;
     val ExpressionAnnotation[*] valueInitializers;
  }

  class TupleExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] parts;
  }
  
  class GenericExprAnn extends ExpressionAnnotation {
     
  }

}

@namespace(uri="http://genericity/types/atl/analysis", prefix="atl_types_analysis")
package analysis {
	class ControlFlow {
	   ref BasicBlock[1] start;
	}


	abstract class BasicBlock {
		ref annotations.ExpressionAnnotation[1] expr;   

		ref BasicBlock[*]#cfPrev cfNext;
		ref BasicBlock[1]#cfNext cfPrev;
	}
	
	class NavigationBasicBlock extends BasicBlock {
	   ref annotations.ExpressionAnnotation[1] subexprStart;
	   ref annotations.ExpressionAnnotation[1] subexprEnd;
	}
	
	class LoopBasicBlock extends BasicBlock {
		ref BasicBlock[0..1] body;
		ref BasicBlock[0..1] next;	    
	}
		
	
	class IfBasicBlock extends BasicBlock {
		ref BasicBlock[1] then;
		ref BasicBlock[1] else;	    	   
	}
}