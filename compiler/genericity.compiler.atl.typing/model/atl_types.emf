@namespace(uri="http://genericity/types/atl", prefix="atl_types")
package atl_types;

//import "http://www.eclipse.org/emf/2002/Ecore";

abstract class Type {
	attr boolean[1] multivalued = false;

    transient attr Object[0..1] metamodelRef;

}

class OclUndefinedType extends Type {
   
}

abstract class PrimitiveType extends Type {
}

class BooleanType extends PrimitiveType {
	ref Metaclass[0..*] kindOfTypes;
}

class IntegerType extends PrimitiveType {
}

class StringType extends PrimitiveType {
}

class FloatType extends PrimitiveType {
}

class TupleType extends Type {
   val TupleAttribute[*] attributes;
}

class MapType extends Type {
   ref Type[1] keyType;
   ref Type[1] valueType;
}

class TupleAttribute {
   attr String[1] name;
   ref Type[1] type;
}

class RefType extends Type {
   
}

class Unknown extends RefType {
   
}

class EmptyCollectionType extends Type {
   
}


class TypeError extends Type {
   
}

class UnknownFeature extends ecore.EStructuralFeature {
   ref EClass[1] theContainingClass;
}

class EmptyCollection extends Type {
   
}

/*
class EnumLiteralType extends Type {
   ref EnumType[1] type;
   attr String[1] value;   
}
*/

class EnumType extends Type {
   attr String[1] name;
   ref EObject[1] eenum;      
}

class Metaclass extends RefType {
   attr String[1] name;
   attr boolean explicitOcurrence;
   ref EClass[1] klass;   

}

abstract class ReflectiveType extends Type {
   
}

class UnionType extends Type {
	ref Type[*] possibleTypes;   
}

class ThisModuleType extends Type {
   
   
}

/**
 * This is to support oclType()
 */
class ReflectiveClass extends ReflectiveType {
   
}

abstract class CollectionType extends Type {
   ref Type[1] containedType;
}

class SequenceType extends CollectionType {
}

class SetType extends CollectionType {  
}


@namespace(uri="http://genericity/types/atl/annotations", prefix="atl_types_annotations")
package annotations {
  abstract class AtlAnnotation {
	//val AtlAnnotation[*]#parent children;
	//ref AtlAnnotation[0..1]#children parent;
  }

  class TransformationAnn extends AtlAnnotation {
  	 ref EObject[1] module;
  
     val MatchedRuleAnn[*] matchedRules;
     val CalledRuleAnn[*] calledRules;
     val LazyRuleAnn[*] lazyRules;
     
     val HelperAnn[*] helpers;
  }

  abstract class RuleAnn extends AtlAnnotation {
    ref EObject rule;
    
    val OutputPatternAnn[1..*] outputPatterns;

	attr String[1] name;
  }
  
  abstract class MatchedRuleAnn extends RuleAnn {
    val ExpressionAnnotation[0..1] filter;
    ref Metaclass[1] outputPatternType;        
  }
  
  class MatchedRuleOneAnn extends MatchedRuleAnn {
  	ref Metaclass[1] inPatternType;   
  }
  
  class MatchedRuleManyAnn extends MatchedRuleAnn {
  	ref Metaclass[2..*] inPatternTypes;   
  }
  
  class LazyRuleAnn extends RuleAnn {
  	ref Metaclass[1] inPatternType;   
    ref Metaclass[1] outputPatternType;   
  }
  
  class CalledRuleAnn extends RuleAnn {
     
  }
  
  
  class OutputPatternAnn extends RuleAnn {
    ref EObject outputPatternElement;
    ref Type[1] type;

     val BindingAnn[*] bindings;
  }

  // TODO: Distinguish the different kind of helpers
  abstract class HelperAnn extends AtlAnnotation {
    ref EObject helper;
	attr String[1] name;
	ref Type[1] returnType;
  	
  	val ExpressionAnnotation[1] expr;
  }

  class ModuleHelperAnn extends HelperAnn {
       
  }
  
  class ContextHelperAnn extends HelperAnn {
	ref Type[1] contextType;
	
	ref CallExprAnn[*]#dynamicResolvers calledBy;
  }
  

  class BindingAnn extends AtlAnnotation {
    ref EObject rule;
	ref EObject binding;
	attr String[0..1] name;
	ref Type[1] sourceType;
	ref Type[1] targetType;
	
	val ExpressionAnnotation[1] value;
	
	ref MatchedRuleOneAnn[*] resolvedBy;
  }

  abstract class ExpressionAnnotation extends AtlAnnotation {
    ref EObject expr;
	ref Type[1] type;
	
	// Reference to EStructuralFeature and the type of the static receptor
	ref EObject[0..1] usedFeature;
	ref EObject[0..1] receptorType;	
  }
  
  
  class LetExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[1] init;
     val ExpressionAnnotation[1] body;
  }
  
  class IfExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[1] ifCondition;
     val ExpressionAnnotation[1] thenPart;
     val ExpressionAnnotation[1] elsePart;
     
  }
  
  class CallExprAnn extends ExpressionAnnotation {
  	val ExpressionAnnotation[1] source;
  	val ExpressionAnnotation[*] arguments;  	   

	ref HelperAnn[1] staticResolver;
	ref ContextHelperAnn[1..*]#calledBy dynamicResolvers;
  }

  abstract class AbstractIteratorExprAnn extends ExpressionAnnotation {
  	val ExpressionAnnotation[1] source;   
 	val ExpressionAnnotation[1] body;    
  }
  
  class IteratorExprAnn extends AbstractIteratorExprAnn {
  }

  class IterateExprAnn extends AbstractIteratorExprAnn {
  	val ExpressionAnnotation[1] resultVar;   
  }

  class CollectionExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] initializers;
  }

  class MapExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] keyInitializers;
     val ExpressionAnnotation[*] valueInitializers;
  }

  class TupleExprAnn extends ExpressionAnnotation {
     val ExpressionAnnotation[*] parts;
  }
  
  class GenericExprAnn extends ExpressionAnnotation {
     
  }

}

