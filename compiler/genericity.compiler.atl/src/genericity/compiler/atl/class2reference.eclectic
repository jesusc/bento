// eclectic class2reference(atl, gbind, type) -> (atl)
eclectic class2reference(atl) -> (atl)

qool class2reference_rewrite(atl, gbind, params) -> (atl)

model queue mNavigationOrAttributeCallExp : atl!NavigationOrAttributeCallExp
model queue mBinding : atl!Binding
model queue mMatchedRule : atl!MatchedRule!

model queue mIntermediateClassBinding     : gbind!IntermediateClassBinding


segment findNavExpr
	current_mm = params!BindingData.all_instances.first.boundMetamodelName
	ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first

	module = atl!Module.all_instances.first
	
	helper_parameter = atl!Parameter.new
	helper_parameter.varName = "obj"
	helper_parameter.type = atl!OclAnyType.new
			
	invoke-external ^eclectic.class2reference_gen_atl(in = gbind) -> (out = atl)
		 entrypoint createSequenceConverter(module, helper_parameter) // The module where it must be attached is passed
	

	forall cb from mIntermediateClassBinding	
		forall nav from mNavigationOrAttributeCallExp
			where nav.source.typeName.eq(cb.conceptContext.name).
			      and(nav.name.eq(cb.conceptReferenceName))
			
			nav.name = nav.name.concat('_tuple_convert')

			it = atl!Iterator.new 
			it.varName = cb.concreteReference.varName

			/*
			filter_view2 = { |o|
				o.is_child_of(ocl_expr).or(o.kind_of(gbind!MetamodelDeclaration))
			}		
			
			atl_expr = invoke-external eclectic.composed_genericity(in = gbind) -> (out = atl)
					 input-view-filter filter_view2
					 output-element ocl_expr[expr.t]
			*/
			
			// TODO: Assuming multivalued -> Check if it is single-valued 
			helper = invoke-external ^eclectic.class2reference_gen_atl(in = gbind) -> (out = atl)
					 entrypoint createTupleAdapter(cb, ocl_model, nav.name, it)
		
		
			module.elements = helper		
		end
	end

	
	forall atlBinding from mBinding
	 	compatible_cbs = gbind!IntermediateClassBinding.all_instances.select { |cb|
		 	atlBinding.value.hasType(cb.concept.name)
	 	}
	 	
	 	compatible_cbs.size.gt(0).if_true {
			atlBinding.value = compatible_cbs.inject(atlBinding.value) { |current_expr, cb|
				it1 = atl!Iterator.new 
				it1.varName = "__v__"
			
				expr = invoke-external ^eclectic.class2reference_gen_atl(in = gbind) -> (out = atl)
					 entrypoint createInvokerForLazyRule(cb, current_expr, it1)
			
				expr
			}
	 	}
	
	
	 	/*
	 	compatible_cbs.size > 0 :if {
	 		
	 	} :elsif compatible_cbs.size == 0 :ifTrue {
	 		
	 	} :ifFalse {
	 		
	 	}
	 	*/
			
	 	
	end
	
	forall cb2 from mIntermediateClassBinding	
		forall matchedRule from mMatchedRule
			ocl_model_element = matchedRule.inPattern.elements.first.type
			
			ocl_model_element.^model.name.eq(current_mm).if_true {
			    cb2.concept.name.eq(ocl_model_element.name).if_true {
					matchedRule.println("selected")
					lazy_rule = atl!LazyMatchedRule.new
					lazy_rule.name = "uniqueLazyRule".concat(cb2.concept.name)
					lazy_rule.inPattern = matchedRule.inPattern
					lazy_rule.outPattern = matchedRule.outPattern
					
					matchedRule.replaceBy(lazy_rule)					

				
					ocl_model_element.name = 'OclAny'
				}
			}
		end		
	end
	
end
end

/*
mappings class2reference_map_feature_bindings(gbind) -> (atl)
  uses ocl2ocl as ocl2ocl

  [expr]
  delegate from _ : gbind!OclExpression 
             to ocl2ocl!generic.t
  
  [expr]
  from gbind : gbind!IteratorExp
    to   atl :   atl!IteratorExp
    
	atl.name = gbind.name
	atl.body      <- gbind.body
	atl.iterators <- gbind.iterators
  end
  
end
*/

tao class2reference_gen_atl(gbind, atl) -> (atl)

template createInvokerForLazyRule(cb : gbind!IntermediateClassBinding, originalBindingExpr : atl!OclExpression, it : atl!Iterator)
atl!IteratorExp {
	name = "collect"
	source = atl!OperationCallExp {
		operationName = "__convertToSequence__"
		source = atl!VariableExp {
			referredVariable = atl!VariableDeclaration {
				varName = "thisModule"
			}
		}
		arguments = originalBindingExpr
	}
	body = atl!IfExp {
		// 
		condition = atl!OperatorCallExp {
			operationName = "="
			source = atl!NavigationOrAttributeCallExp {
				name = "name"
				source = atl!OperationCallExp {
					operationName = "oclType"
					source = atl!VariableExp {
						referredVariable = it // atl!VariableDeclaration { varName = "self" }
					}
				}
			}
			arguments = atl!StringExp {
				stringSymbol = "Tuple"
			}
		}
		
		thenExpression = atl!IfExp {

			condition = atl!OperatorCallExp {
				operationName = "="
				source = atl!OperationCallExp {
					operationName = "get"
					source = atl!OperationCallExp {
						operationName = "asMap"
						source = atl!VariableExp {
							referredVariable = it
						}
					}
					arguments = atl!StringExp {
						stringSymbol = "type__"
					}
				}
				arguments = atl!StringExp {
					stringSymbol = cb.concept.name
				}
			}

			thenExpression = atl!OperationCallExp {
				operationName = "uniqueLazyRule".concat(cb.concept.name)
				source = atl!VariableExp {
					referredVariable = atl!VariableDeclaration {
						varName = "thisModule"
					}
				}
				arguments = atl!VariableExp {
					referredVariable = it
				}
			}
			elseExpression = atl!VariableExp {
				referredVariable = it
			}
		}
		elseExpression = atl!VariableExp {
			referredVariable = it
		}
	}
	iterators = it
	//iterators = it : atl!Iterator {
	//	varName = "__v__"
	//}
	
}


end

template createTupleAdapter(cb : gbind!IntermediateClassBinding, atl_model : atl!OclModel, helperName : _!String, i : atl!Iterator) 
	atl!Helper {
		definition = atl!OclFeatureDefinition {
			feature = atl!Attribute {
				name = helperName
				initExpression = atl!IteratorExp {
					name   = 'collect'
					source = atl!NavigationOrAttributeCallExp {
						name = cb.conceptReferenceName
						source = atl!VariableExp {
							referredVariable = atl!VariableDeclaration { varName = "self" }
						}
					}
					//iterators = i : atl!Iterator {
					//	varName = cb.concreteReference.varName
					//}					
					iterators = i // TODO: Allow referencing "i"
					body = atl!TupleExp {
						tuplePart = from fb : cb.featureBindings* to atl!TuplePart {
							// TODO: Assuming featureBinding is renaming feature
							varName = fb.conceptFeature
							initExpression = atl!VariableExp {
								// This is not the best way to do this... but it does the trick
								// until a general mapping including renaming feature is done
								referredVariable = fb.concreteFeature.eq("self").if_else({ 
									v = atl!VariableDeclaration.new
									v.varName = "self"
									v
								}, { i })
							}
						}
						tuplePart = atl!TuplePart {
							varName = 'type__'
							initExpression = atl!StringExp {
								stringSymbol = cb.concept.name
							}
						}
					}
				}
 
				type = atl!OclAnyType { }
			}
			context_ = atl!OclContextDefinition {
				context_ = atl!OclModelElement { 
					name  = cb.conceptContext.name
					^model = atl_model 
				}
			}		
		}
	}
end

template createSequenceConverter(module : atl!Module, p : atl!Parameter)
atl!Helper {
	module = module
	definition = atl!OclFeatureDefinition {
		feature = atl!Operation {
			name = "__convertToSequence__"
			parameters = p
			returnType = atl!OclAnyType { }
			body = atl!IfExp {
				thenExpression = atl!SequenceExp { }
				condition = atl!OperatorCallExp {
					operationName = "="
					source = atl!VariableExp { 
						referredVariable = p
					}
					arguments = atl!OclUndefinedExp { }
				}
				elseExpression = atl!CollectionOperationCallExp {
					operationName = "flatten"
					source = atl!SequenceExp {
						elements = atl!VariableExp { 
							referredVariable = p							
						}
					}
				}
			}
		}
	}
}
end

end