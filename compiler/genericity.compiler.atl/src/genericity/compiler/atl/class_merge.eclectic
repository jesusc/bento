/**
 * Rewrites an ATL transformation to avoid conflicting rules.
 * This should be done after the transformation has been adapted, as it 
 * does not look the binding for the rewriting, just the rules.
 */ 
eclectic class_merge(atl) -> (atl)

qool class_merges_rewrite(atl, gbind, params) -> (atl)

model rt
  class ConflictedRule
  	ref rule_   : atl!MatchedRule
	ref type_   : _!Any // EClass
	att name_   : _!String
    att type_name : _!String
	att has_filter : _!Boolean
  end

end

model queue mMatchedRule : atl!MatchedRule!
local queue pConflicted : rt!ConflictedRule
model queue mBinding : atl!Binding


model queue mNavigationOrAttributeCallExp : atl!NavigationOrAttributeCallExp
model queue mClassBinding             : gbind!ClassBinding


model queue mHelper : atl!Helper!

model queue mVirtualMetaclass      : gbind!VirtualMetaclass 
model queue mVirtualClassBinding   : gbind!VirtualClassBinding
model queue mConcreteMetaclass     : gbind!ConcreteMetaclass


segment find_conflicting_rules
	current_mm = params!BindingData.all_instances.first.boundMetamodelName

	check_binding_applicable_to_rule = { |in_pattern_element_, cb|
		in_pattern_element_.type.^model.name.eq(current_mm).and(
			    cb.concept.name.eq(in_pattern_element_.type.name))
	}

	rule_types_are_overlapped = { |in_pattern_element_1, in_pattern_element_2|
		in_pattern_element_1.type.^model.name.eq(in_pattern_element_2.type.^model.name).and(
			    in_pattern_element_2.type.name.eq(in_pattern_element_1.type.name))
	}


	conflicted = _!MutableMap.new
	forall mr1 from mMatchedRule	
      where conflicted.include(mr1.name).not

		in_pattern_element1 = mr1.inPattern.elements.first // assumes rules with one input element
		// Assuming only one class-binding applicable per rule...
		cb1 = gbind!ClassBinding.all_instances.select { |cb| check_binding_applicable_to_rule.call(in_pattern_element1, cb) }.first

		cb1.if_true {
			forall mr2 from mMatchedRule	
			 where mr1.eq(mr2).not.
			       and(conflicted.include(mr2.name).not)
			       
				in_pattern_element2 = mr2.inPattern.elements.first 

				// Check if the types of the rules already overlap, in such case they are not
				// selected since the designer should have been aware of the conflicts 
				// (so proper filers should have been written)		
				rule_types_are_overlapped.call(in_pattern_element1, in_pattern_element2).if_false {

					cb2 = gbind!ClassBinding.all_instances.select { |cb| check_binding_applicable_to_rule.call(in_pattern_element2, cb) }.first
					cb2.if_true {
						cb1.conflict_with(cb2).if_true {
							" rule ".concat(mr1.name).concat(" conflict with ").println(mr2.name)
							conflicted.^put(mr1.name, true)
							conflicted.^put(mr2.name, true)
						}
					}
				
				}
			end
		}
	end
	
	// This works almost by chance. As IDC is event-based one should not be allowed
	// to write an expression that depends on values of the forall...
	conflicted.keys.each { |rule_name|
		r    = atl!MatchedRule.all_instances.find { |r| r.name.eq(rule_name) } 
		type = r.inPattern.elements.first.type

		atl_type = r.atlType(type)
		
		cf = rt!ConflictedRule.new
		cf.rule_ = r
		cf.type_ = atl_type.klass
		cf.name_ = r.name
		cf.type_name = type.name
		cf.has_filter = r.inPattern.filter.is_nil.not
		
		emit cf to pConflicted
	}
end

segment make_rules_unique_lazy
	module = atl!Module.all_instances.first

	forall cf from pConflicted
		matchedRule = cf.rule_
		inPatternElement  = matchedRule.inPattern.elements.first
	
		matchedRule.name.println("Converted to unique lazy rule (class merge): ")
		
		filter    = matchedRule.inPattern.filter
		rule_name = matchedRule.name //"uniqueLazyRule".concat(cb2.concept.name)
		
		lazy_rule = atl!LazyMatchedRule.new
		lazy_rule.variables = matchedRule.variables.map { |v| v }

		lazy_rule.isUnique = true
		lazy_rule.commentsBefore = "-- Rule from ".concat(matchedRule.name)
		lazy_rule.name = rule_name
		lazy_rule.inPattern = matchedRule.inPattern
		lazy_rule.outPattern = matchedRule.outPattern

		matchedRule.replaceBy(lazy_rule)	

		// Copied from class merge
		filter.is_nil.if_false {			
			// This works by change, because the parameter has the same name as the
			// replaced varDeclaration, but the elements in the AST does not point
			// to the new parameter. However, the ATL serializer does not matter because
			// it just looks at the varName			
			p = atl!Parameter.new
			p.varName = inPatternElement.varName
			p.type = atl!OclAnyType.new
			// inPatternElement.replaceBy(p)
			
			helper = invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
			 		      entrypoint createFilterForLazyCall_ForClassMerge(lazy_rule, filter, rule_name.concat('__filter__'), p)
			module.elements = helper		
			
			rule_name.println("Moved filter to helper: ")				
		}
		
	end

end

segment create_end_point_rules
	module = atl!Module.all_instances.first
	current_mm = params!BindingData.all_instances.first.boundMetamodelName
	ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first

 /*
  varToForceEvaluation2 : OclAny = BENDER!State.allInstances().debug('states')->collect(i |
   thisModule.synchronization_all(i.debug('states'))
  );
  */
  
 	endpoint = atl!CalledRule.new
	endpoint.name = "Rule_To_".concat('_ForceTransformation')
	endpoint.isEndpoint = true

	module.elements = endpoint
				 
	forall cf from pConflicted
		rule_name = cf.name_
		type_name = cf.type_name

		it = atl!Iterator.new
		it.varName = "i"

		filter_condition = cf.has_filter.if_else({
			invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
		    			  entrypoint createThisModuleCall_ForClassMerge(module, rule_name.concat('__filter__'), it)						
		}, {	
			b = atl!BooleanExp.new
			b.booleanSymbol = true
			b
		})
			
		endpoint.variables = invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
			 entrypoint createVariableDclInEntryPoint(it, rule_name, type_name, ocl_model, filter_condition)

		// module.elements = entrypoint_rule
	end


	helper_parameter = atl!Parameter.new
	helper_parameter.varName = "obj"
	helper_parameter.type = atl!OclAnyType.new
			
	invoke-external ^eclectic.virtual_class_gen_atl(in = gbind) -> (out = atl)
		 entrypoint createSequenceConverter(module, helper_parameter) // The module where it must be attached is passed
end

segment rewrite_bindings
	current_mm = params!BindingData.all_instances.first.boundMetamodelName
	ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first

	forall cf from pConflicted
		rule_name = cf.name_
		type      = cf.type_
		type_name = cf.type_name

		forall atlBinding from mBinding
		 where atlBinding.compatible_with(type)
			// check if the binding is compatible!		

			it1 = atl!Iterator.new 
			it1.varName = "__v__"
		
			// The call expression is: Sequence { thisModule.ruleName(__v__), __v__ }
			// Because __v__ needs to be propagated for further transformation by other rules
			this_module_invocation = invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
					 entrypoint createThisModuleCall_ForClassMerge(atlBinding, rule_name, it1)

			call_expr = atl!SequenceExp.new 
			call_expr.elements = this_module_invocation
			var_ref0 = atl!VariableExp.new
			var_ref0.referredVariable = it1
			call_expr.elements = var_ref0

			expr = cf.has_filter.if_else({
				check_filter = invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
		     				  entrypoint createThisModuleCall_ForClassMerge(atlBinding, rule_name.concat('__filter__'), it1)						
				if_exp     = atl!IfExp.new
				if_exp.condition      = check_filter
				if_exp.thenExpression = call_expr
				
				var_ref = atl!VariableExp.new
				var_ref.referredVariable = it1
				if_exp.elseExpression = var_ref
			  	if_exp
			}, {	
				call_expr				
			})

			check_type_and_call = atl!IfExp.new
			condition           = atl!OperationCallExp.new
			condition.operationName = "oclIsKindOf"
			varexp_condition = atl!VariableExp.new
			varexp_condition.referredVariable = it1
			condition.source = varexp_condition
			model_element = atl!OclModelElement.new
			model_element.name = type_name 
			model_element.^model = ocl_model
			condition.arguments = model_element
						
			check_type_and_call.condition = condition
			check_type_and_call.thenExpression = expr
			varexp_else = atl!VariableExp.new
			varexp_else.referredVariable = it1
			check_type_and_call.elseExpression = varexp_else

			invoker = invoke-external ^eclectic.class_merge_gen_atl(in = gbind) -> (out = atl)
					 entrypoint createInvokerForLazyRule_ForClassMerge(atlBinding, atlBinding.value, it1, check_type_and_call)

			atlBinding.value = invoker
		end
		
	end


end

end


tao class_merge_gen_atl(atl, gbind) -> (atl)

	template createThisModuleCall_ForClassMerge(element_not_used : atl!LocatedElement, ruleName : _!String, it : atl!Iterator) 
		atl!OperationCallExp {
			operationName = ruleName
			source = atl!VariableExp {
				referredVariable = atl!VariableDeclaration {
					varName = "thisModule"
				}
			}
			arguments = atl!VariableExp {
				referredVariable = it
			}
		}
	end
	
	template createFilterForLazyCall_ForClassMerge(mr : atl!MatchedRule, atl_expr : atl!OclExpression, helperName : _!String, parameter : atl!Parameter) 
		atl!Helper {
			definition = atl!OclFeatureDefinition {
				feature = atl!Operation {
					name = helperName
					parameters = parameter
					body = atl_expr
					returnType = atl!BooleanType { }
				}		
			}
		}
	end

	template createInvokerForLazyRule_ForClassMerge(b : atl!Binding, originalBindingExpr : atl!OclExpression, it : atl!Iterator, bodyExpr : atl!OclExpression)
		atl!CollectionOperationCallExp {
			operationName = "flatten"
			source = atl!IteratorExp {
				name = "collect"
				source = atl!OperationCallExp {
					operationName = "__convertToSequence__"
					source = atl!VariableExp {
						referredVariable = atl!VariableDeclaration {
							varName = "thisModule"
						}
					}
					arguments = originalBindingExpr
				}
				body = bodyExpr
				iterators = it
			}
		}
	end

	template createVariableDclInEntryPoint(it : atl!Iterator, originalRule : _!String, typeName : _!String, ocl_model : atl!OclModel, filter_condition : atl!OclExpression) 
		atl!RuleVariableDeclaration {
				varName = originalRule.concat("_varToForceEvaluation")
				type = atl!OclAnyType { }
				initExpression = atl!IteratorExp {
					name = "collect"
					source = atl!OperationCallExp {
						operationName = "allInstances"
						source = atl!OclModelElement {
							^model = ocl_model
							name = typeName
						}
					}					
					body = atl!IfExp {
						thenExpression = atl!OperationCallExp {
							operationName = originalRule
							source = atl!VariableExp {
								referredVariable = atl!VariableDeclaration {
									varName = "thisModule"
								}						
							}
							arguments = atl!VariableExp {
								referredVariable = it
							}
						}
						condition = filter_condition
						elseExpression = atl!VariableExp {
									referredVariable = it
						}
					}
					iterators = it
				}
			}
	end

end
