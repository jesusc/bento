attribution propagate_instantiation(comp) -> (inst)
/*
  inh source  : socl!OclExpression
  inh rest    : _!List
	*/

  inh sourceAdaptations : _!List
  inh targetAdaptations : _!List
  

  inh component  : inst!Component
  syn adaptation : inst!Action
  syn executions : _!List
  
  rule comp!DefinitionRoot 
    ci = inst!ComponentInstantiation.new
    ci.actions = self.component[adaptation] 
  end

  rule comp!CompositeComponent  
  	// Propagate adaptations
    self[adaptation] <- self.composition.step[adaptation] 

	// 
	//self.composition.step[executions]
	is_parent = self.container_.kind_of(comp!DefinitionRoot)
	
	self[executions] <- is_parent.if_else({
		e = inst!ExecuteTransformation.new
		e.adaptedTransformation = self.composition.step[adaptation] 
		l = _!List.new.add(e)
		l
	}, {
		l = _!List.new
		l
	})
	
	 // TODO: I would like to be able to execute not adapted transformations directly...

	//_!List.new.add(1)
    //ci = inst!ComponentInstantiation.new  
  	
  end

  rule comp!Apply
  	self.component[sourceAdaptations] <- self.component.inputModels.select { |i| r = i.boundConcept.is_nil.not }
  	self.component[targetAdaptations] <- self.component.targetModels.select { |i| r = i.boundConcept.is_nil.not }
  
  	self[adaptation] <- self.component[adaptation]
  end

  // TODO: I should specify that this rule will have several activations (one per each
  //       set of inherited attributes provided) -> will therefore be executed lazily
  rule comp!TransformationComponent 
  	at = inst!AdaptTransformation.new
  	at.actions = self[sourceAdaptations].map { |p| 
		i = inst!AdaptTransformationStep.new
		i.component = self
		i.binding   = p.binding
		// TODO: Specify the technology that is adapted, e.g., ATL
		i
  	} 

  	// TODO: Target adaptations  	
  	self[adaptation] <- at
  end
  