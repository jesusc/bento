
attribution propagate_instantiation(comp) -> (inst)
  inh sourceAdaptations : _!List
  inh targetAdaptations : _!List
  syn adaptation : inst!Action
  
  rule comp!DefinitionRoot 
    ci = inst!ComponentInstantiation.new
    ci.transformation = self.component[adaptation] 
  end

  rule comp!CompositeComponent  
  	// Propagate adaptations
    self[adaptation] <- self.composition.step[adaptation] 
	

	/*
  	// Propagate adaptations
    self[adaptation] <- self.composition.step[adaptation] 

	// 
	//self.composition.step[executions]
	is_parent = self.container_.kind_of(comp!DefinitionRoot)
	
	self[executions] <- is_parent.if_else({
		e = inst!ExecuteTransformation.new
		e.adaptedTransformation = self.composition.step[adaptation] 
		l = _!List.new.add(e)
		l
	}, {
		l = _!List.new
		l
	})
	
	 // TODO: I would like to be able to execute not adapted transformations directly...

	//_!List.new.add(1)
    //ci = inst!ComponentInstantiation.new  
	*/
  end

  rule comp!Apply
  	// inputModels -> input parameters
  	adaptations = self.inputModels.select { |m| x = m.binding.is_nil.not }.map { |m2|
  		adapt = inst!AdaptWithBinding.new
  		adapt.parameterIndex = self.inputModels.index_of(m2)
  		adapt.conceptModel   = m2.model
		adapt.appliedBinding = m2.binding
  		adapt
  	}
  	
  	self.component[sourceAdaptations]  <- adaptations

	self[adaptation] <- self.component[adaptation]
  end

  // TODO: I should specify that this rule will have several activations (one per each
  //       set of inherited attributes provided) -> will therefore be executed lazily
  rule comp!TransformationComponent 
  	t = inst!AdaptedTransformation.new
  	t.template = self.template
  	t.requiredAdaptations = self[sourceAdaptations].map { |a| 
		a.concreteModel = self.sourceModels.get(a.parameterIndex)		
		a
  	} 

  	self[adaptation] <- t
  end
  