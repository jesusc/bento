/**
 * Rewrites an ATL transformation according to a binding model.
 */
qool adapt_adapters(atl, gbind, params) -> ()

model matches
  class MatchedRenamingHelper
	ref featureBinding    : gbind!RenamingFeatureBinding
	ref concreteMetaclass : gbind!ConcreteMetaclass
  end

  class MatchedOclHelper
	ref featureBinding    : gbind!OclFeatureBinding
	ref concreteMetaclass : gbind!ConcreteMetaclass
  end

  class MatchedAttribute2ClassBindingRule
	ref rule          : gbind!MatchedRule
	ref classBinding  : gbind!ClassBinding
  end
end

// rt model for traces if needed!
// local queue genericQ    : rt!generic

// ATL elements
// model queue mOclModelElement : atl!OclModelElement

// GBind elements
//model queue mClassBinding           : gbind!ClassBinding
model queue mRenamingFeatureBinding : gbind!RenamingFeatureBinding
model queue mOclFeatureBinding      : gbind!OclFeatureBinding
model queue mMatchedRule : atl!MatchedRule
model queue mClassBinding           : gbind!ClassBinding
model queue mOperationCallExp : atl!OperationCallExp



// Pattern queues
//local queue pRelevantOclModelElements : atl!OclModelElement
//local queue pMatchedClassBinding1     : matches!MatchedClassBinding
//local queue pMatchedClassBindingN     : matches!MatchedClassBinding
local queue pMatchedRenamingBinding   : matches!MatchedRenamingHelper
local queue pMatchedOclBinding        : matches!MatchedOclHelper
local queue pMatchedAttribute2ClassBindingRule : matches!MatchedAttribute2ClassBindingRule
local queue pClassBinding_Class2Attribute           : gbind!ClassBinding

//
// Begin-of patterns
//

segment findRulesForWhewnClause
	current_mm = params!BindingData.all_instances.first.boundMetamodelName

	forall cb1 from mClassBinding
	 where cb1.whenClause.is_nil.not

		emit cb1 to pClassBinding_Class2Attribute
		
		forall mr from mMatchedRule
			in_pattern_element = mr.inPattern.elements.first // assumes rules with one input element

			in_pattern_element.type.^model.name.eq(current_mm).if_true {
			    cb1.concept.name.eq(in_pattern_element.type.name).if_true {
			    	m = matches!MatchedAttribute2ClassBindingRule.new
			    	m.rule         = mr
			    	m.classBinding = cb1
			    	emit m to pMatchedAttribute2ClassBindingRule
				}
			}
		end
	end
end

// Find features that needs to be transformed to helpers
// 	* Renaming bindings       -> MatchedRenamingHelper
//  * Ocl bindings (adapters) -> MatchedOclHelper
segment findBindingFeatures
	forall r from mRenamingFeatureBinding
	 where r.conceptFeature.eq(r.concreteFeature).not
		m = matches!MatchedRenamingHelper.new
		m.featureBinding    = r

		r.qualifier.is_nil.if_else({
			// I would like to use a pattern here...
			m.concreteMetaclass = gbind!ClassBinding.all_instances.select { |cb| cb.concept.name.eq(r.conceptClass.name) }.first.concrete.first 		
		}, {
			m.concreteMetaclass = r.qualifier
		})
		
		emit m to pMatchedRenamingBinding
	end

	forall o from mOclFeatureBinding
		mo = matches!MatchedOclHelper.new
		mo.featureBinding    = o

		// the same as above
		o.qualifier.is_nil.if_else({
			r = o // TODO: Scoping is wrong: r is "visible" from xText point of view from here, but defined above for another scope
			mo.concreteMetaclass = gbind!ClassBinding.all_instances.select { |cb| cb.concept.name.eq(r.conceptClass.name) }.first.concrete.first
		}, {
			mo.concreteMetaclass = o.qualifier
		})
		
		emit mo to pMatchedOclBinding
	end
end 
//
// End-of Patterns
//


//
// Begin-of rules
//

segment CreateHelperForRenamingFeature
	forall m from pMatchedRenamingBinding
		// ref featureBinding    : gbind!RenamingFeatureBinding
		// ref concreteMetaclass : gbind!ConcreteMetaclass

		// invoke gen_atl[atl, gbind].createRenamingHelper(m.featureBinding, m.concreteMetaclass, m)
		
		// some transformations has an entrypoint, some they don't
		
		// two basic kinds of invocation + variants
		// schedule external 
		// schedule internal
		// invoke   external
		// invoke   internal
		// * what is the meaning of external -> the trace is not shared with this transformation
		//                                      it is an independent transformation -> do something and return a value
		//
		// * how to integrate the result with this transformation
		//        1. get a value and assign somewhere
		//        2. re-apply a pattern to lookup a value (weird if we invoke a m2m) 
		//           it could be interesting to be able to find an interesting value in the generated ones
		//           (I may need to delete elements...)
		//
		// * instantiation, then invocation 
		//     - invocation may need to call an entry point... (e.g., templates)
		
		current_mm = params!BindingData.all_instances.first.boundMetamodelName
		
		ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first
		
		helper = invoke-external eclectic.gen_atl(in = gbind) -> (out = atl)
				 entrypoint createRenamingHelper(m.featureBinding, m.concreteMetaclass, ocl_model)
		
		
		module = atl!Module.all_instances.first
		module.elements = helper
		// conceptFeature
		// conceptClass : ConceptMetaclass
		// qualifier... ConcreteMetaclass
		// concreteFeature
	end    
end

segment CreateHelperForOclFeature
	forall mo from pMatchedOclBinding
		current_mm = params!BindingData.all_instances.first.boundMetamodelName

		ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first
		ocl_expr  = mo.featureBinding.concrete
		
		/*
		 * Recursive closures are not supported yet!
		 * 
		filter_view = { |o|
			o.eq(ocl_expr).if_else({
				1.eq(1) // true				
			}, {
				o._container.is_nil.if_true({
					0.eq(1) // false
				}, {
					filter_view.call(o._container)
				})
			})
		}
		*/

		// The same using a Java helper
		filter_view = { |o|
			o.is_child_of(ocl_expr).or(o.kind_of(gbind!MetamodelDeclaration))
		}		


		// Creating a view
		//   1. One way would be to pass a queue that contains the elements that contains (or will contain) the elements
		//      which form of the model seen by the invoked transformation, thus acting as a filter. The problem of this
		//      is that I needed a new queue per invocation, and now queues are instantiated once at the beginning of the
		//	    the transformation. New kind of queue -> dynamic queue??
		//   2. Declarative approach: a set of constructs to describe what is visible: e.g., containedIn, referencedBy, etc.
		//   3. A closure with a filter expression 
		atl_expr = invoke-external eclectic.composed_genericity(in = gbind) -> (out = atl)
				 input-view-filter filter_view
				 output-element ocl_expr[expr.t]

		helper = invoke-external eclectic.gen_atl(in = gbind) -> (out = atl)
				 entrypoint createOclHelper(mo.featureBinding, mo.concreteMetaclass, ocl_model, atl_expr)
		
		
		module = atl!Module.all_instances.first
		module.elements = helper
	end
end


segment AdaptRuleForAttribute2ClassBinding
	current_mm = params!BindingData.all_instances.first.boundMetamodelName

	forall ma1 from pMatchedAttribute2ClassBindingRule
		rule = ma1.rule
		type = rule.inPattern.elements.first.type	
      
      	call = atl!NavigationOrAttributeCallExp.new
      	call.name = type.name.concat('__filter__')
      	v = atl!VariableExp.new 
        v.referredVariable = rule.inPattern.elements.first      	
      	call.source = v

		rule.inPattern.filter.is_nil.if_else({
			inP = rule.inPattern
        	inP.filter = call      			
		}, {
	        operator = atl!OperatorCallExp.new
	        operator.operationName = 'and'
	        operator.source = rule.inPattern.filter
	        operator.arguments = call			
		})
	end

	forall op from mOperationCallExp
	 where op.operationName.eq("oclIsKindOf") // TODO: what about oclIsTypeOf!!!
	
		ocl_model_element = op.arguments.first

		ocl_model_element.^model.name.eq(current_mm).if_true {	
			cb = gbind!ClassBinding.all_instances.select { |cb1| cb1.concept.name.eq(ocl_model_element.name) }.first
			cb.is_nil.if_false {
				
				// TODO: Decide where to put this adaptation (in this module...?)
				// Adapt
			    type = ocl_model_element
      			container = op._refContainer
      			containing_property = op.containing_property
      			
      			create_let = { 
      				let_exp = atl!LetExp.new
					vd = atl!VariableDeclaration.new
			        vd.id = "__unique_id__".next_id
		    	    vd.varName = vd.id
		        	vd.type = atl!OclAnyType.new        
		        	vd.initExpression = op.source 
      				let_exp.variable = vd
      				let_exp
      			}
      			let = create_let.call
      			
			    // Re-arrange oclIsKindOf -> source now is Let variable
      			v_exp = atl!VariableExp.new 
		        v_exp.referredVariable = let.variable
      			v_exp = op.source 

			    call = atl!NavigationOrAttributeCallExp.new
      			call.name = type.name.concat("__filter__")
      			v_exp2 = atl!VariableExp.new
      			v_exp2.referredVariable = let.variable
				call.source = v_exp2

      			//let.in_ = call

				if_exp = atl!IfExp.new
				condition = op
      			v_exp3 = atl!VariableExp.new 
		        v_exp3.referredVariable = let.variable
				op.source = v_exp3
				
				if_exp.condition      = condition
				if_exp.thenExpression = call
				false_value = atl!BooleanExp.new
				if_exp.elseExpression = false_value
				
				let.in_ = if_exp
     
      			container.set_inner_expression(let, containing_property)
      			//container.put_expression_in_container(let)
				

				// End-of adaptation 
			}
		}	

	end
end

segment CreateHelperForAttribute2ClassBinding
	current_mm = params!BindingData.all_instances.first.boundMetamodelName

// This fails with: Incompatible stack heights
//	forall cb2 from mClassBinding
//	 where cb2.whenClause.is_nil.not

	forall cb_c2a from pClassBinding_Class2Attribute
		ocl_model = atl!OclModel.all_instances.select { |atl_model| atl_model.name.eq(current_mm) }.first
		ocl_expr  = cb_c2a.whenClause
		
		// The same using a Java helper
		filter_view2 = { |o|
			o.is_child_of(ocl_expr).or(o.kind_of(gbind!MetamodelDeclaration))
		}		

		atl_expr = invoke-external eclectic.composed_genericity(in = gbind) -> (out = atl)
				 input-view-filter filter_view2
				 output-element ocl_expr[expr.t]

		// The helper is attached to the concept class, expecting it to be renamed in subsequent phases
		helper = invoke-external eclectic.gen_atl(in = gbind) -> (out = atl)
				 entrypoint createWhenClauseHelper(cb_c2a.concept, ocl_model, atl_expr)
		
		
		module = atl!Module.all_instances.first
		module.elements = helper
	end
end


// End-of rules
