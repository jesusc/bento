/**
 * Rewrites an ATL transformation according to a binding model.
 */
qool rewrite_class1(atl, gbind) -> ()

model matches
  class MatchedClassBinding
	ref oclModelElement : atl!OclModelElement
	ref classBinding    : gbind!ClassBinding
  end

  class MatchedRenamingHelper
	ref featureBinding    : gbind!RenamingFeatureBinding
	ref concreteMetaclass : gbind!ConcreteMetaclass
  end
end

// rt model for traces if needed!
// local queue genericQ    : rt!generic

// ATL elements
model queue mOclModelElement : atl!OclModelElement

// GBind elements
model queue mClassBinding           : gbind!ClassBinding
model queue mRenamingFeatureBinding : gbind!RenamingFeatureBinding

// Pattern queues
local queue pRelevantOclModelElements : atl!OclModelElement
local queue pMatchedClassBinding      : matches!MatchedClassBinding
local queue pMatchedRenamingBinding   : matches!MatchedRenamingHelper

//
// Begin-of PATTERNS
//

/**
 * Finds all OclModelElements that refers to the meta-model
 * being bound (i.e., the meta-model that the binding DSL refers to)
 */
segment findRelevantOclModelElements
	current_mm = gbind!BindingModel.all_instances.get(0).metamodel

	forall o from mOclModelElement
		o.^model.is_nil.if_false {
			o.^model.name.eq(current_mm).if_true({
				emit o to pRelevantOclModelElements				
			})
		}
	end    
end

/**
 * Matches OclModelElements related to a ClassBinding that
 * specifies its binding to a concrete metaclass.
 */
segment findConceptRef
	forall o from pRelevantOclModelElements
		// TODO: Restrict to 1:1 class bindings (probably another pattern)
		forall cb from mClassBinding		
		    cb.concept.name.eq(o.name).if_true {
		    	m = matches!MatchedClassBinding.new
		    	m.oclModelElement = o
		    	m.classBinding    = cb
		    	emit m to pMatchedClassBinding
		    }
		end
	end    
end


//
// End-of Patterns
//

// =============================================================== //

//
// Begin-of rules
//

segment RenameConceptClass		
	forall m from pMatchedClassBinding
		oclModelElement = m.oclModelElement		
		oclModelElement.name = m.classBinding.concrete.first.name		
	
	    oclModelElement.name.println("Changed: ")
	end
end

// Create helper for renaming feature

segment findRenamingFeatures
	forall r from mRenamingFeatureBinding
		m = matches!MatchedRenamingHelper.new
		m.featureBinding    = r

		r.qualifier.is_nil.if_else({
			// I would like to use a pattern here...
			m.concreteMetaclass = gbind!ClassBinding.all_instances.select { |cb| cb.concept.name.eq(r.conceptClass.name) }.first.concrete.first 		
		}, {
			m.concreteMetaclass = r.qualifier
		})
		
		emit m to pMatchedRenamingBinding
	end
end 

segment CreateHelperForRenamingFeature
	forall m from pMatchedRenamingBinding
		// invoke gen_atl[atl, gbind].createRenamingHelper(m.featureBinding, m.concreteMetaclass, m)
		
		// some transformations has an entrypoint, some they don't
		
		// two basic kinds of invocation + variants
		// schedule external 
		// schedule internal
		// invoke   external
		// invoke   internal
		// * what is the meaning of external -> the trace is not shared with this transformation
		//                                      it is an independent transformation -> do something and return a value
		//
		// * how to integrate the result with this transformation
		//        1. get a value and assign somewhere
		//        2. re-apply a pattern to lookup a value (weird if we invoke a m2m) 
		//           it could be interesting to be able to find an interesting value in the generated ones
		//           (I may need to delete elements...)
		//
		// * instantiation, then invocation 
		//     - invocation may need to call an entry point... (e.g., templates)
		
		invoke-external gen_atl[atl][gbind]
		
		
		"--".println(m.concreteMetaclass)
		// conceptFeature
		// conceptClass : ConceptMetaclass
		// qualifier... ConcreteMetaclass
		// concreteFeature
	end    
end

// End-of rules
