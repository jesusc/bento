eclectic typecheck_atl (atl) -> (typ)


patterns atl_patterns(atl)
	def AttributeHelper  -> (f)
		f : atl!OclFeatureDefinition {
			feature = p : atl!Attribute { }
		}
	end

	def OperationHelper  -> (f)
		f : atl!OclFeatureDefinition {
			feature = p : atl!Operation { }
		}
	end
end

/**
 * TOOD:
 *   - flow.nodes->select(n | n.isMultiChoice)->collect(n | n.nodeGenerator)
 *   - Instead of multivalued = true/false -> integer counting the sequence nesting
 */
attribution attr_typecheck_atl(atl) -> (typ)
	//uses make as make
	uses atl_patterns as atl_patterns
	
	syn type : typ!Type
	
	// Setters
	rule atl!OclExpression
		// TODO: Generate only to meaningful expressions (e.g., UML!Class is an expression)
		type = type[self]
		ann  = typ!ExpressionAnnotation.new
		ann.type = type
		ann.expr = self
	end 
	
	// Helpers
	rule atl_patterns!AttributeHelper
		body_type  = type[self.feature.initExpression]
		annotation = typ!HelperAnnotation.new
		annotation.helper = self
		annotation.type   = body_type
		annotation.name   = self.feature.name
		// TODO: Invoke tao to create things... (or just embed object syntax)
	end

	// Rules
	// Include SimpleInPatternElement
	rule atl!VariableDeclaration 
		self.varName.eq("self").or(self.varName.eq("thisModule")).or(self.kind_of(atl!Iterator)).if_false {
			self.initExpression.is_nil.if_else({
				type[self] <- type[self.type]
			}, {
				type[self] <- type[self.initExpression]
			})
		}
	end

	//rule atl!RuleVariableDeclaration 
	//	type[self] <- type[self.type]
	//end

	//rule atl!Iterator
	//	// Depends on kind of IteratorExp -> iterate is different
	//	iterator_exp = self._refContainer
	//	type[self] <- type[iterator_exp.source]
	//end

	rule atl!IteratorExp
		// The type of the first iterator is the type of receptor object, but 
		// not multivalued!
		it = self.iterators.first
		type[it] <- self.copyType(type[self.source], false)
	
		// This is not actually needed, as there are separate 
		// classes: Iterator vs. Iterate
		rest = self.iterators.tail.map { |rit|
			initType = type[rit.initExpression]
			type[rit] <- initType
			initType
		}
		
		// Different cases: collect, select, iterate
		type[self] <- self.iteratorType(self.name, type[self.source], type[self.body], rest)
	end

	rule atl!IterateExp
		it = self.iterators.first
		type[it] <- self.copyType(type[self.source], false)
		
		rest = self.result.as_list.map { |r| 
			x = type[r]
			x
		}

		type[self] <- self.iteratorType("iterate", type[self.source], type[self.body], rest)	
	end

	rule atl!OclModelElement
		m = typ!Metaclass.new
		m.name = self.name
		m.klass = self.eClass
		type[self] <- m
	end

	// Expressions
	rule atl!IfExp
		t1 = type[self.thenExpression]		
		t2 = type[self.elseExpression]		
		
		type[self] <- self.findCommonTypePossibleUnion(t1, t2)	
	end

	rule atl!LetExp
		type[self] <- type[self.in_]	
	end

	rule atl!OperationCallExp!
		t       = type[self.source]		
		// thisModule??'
		// This only works because the pattern module is at the beginning... 
		// (otherwise, it returns an empty collection (QoolTransformationBase access the queue to retrieve the objects))
		arguments  = self.arguments.map { |a| x = type[a] }
		operations = atl_patterns!OperationHelper.all_instances.select { |h| 
			h.feature.name.eq(self.operationName)
		}
		ft = self.operationType(t, self.source, arguments, operations)
		
		type[self] <- ft
	end

	rule atl!OperatorCallExp
		// Assume no coercions
		t = type[self.source]
		type[self] <- self.copyType(t, t.multivalued)
	end

	rule atl!NavigationOrAttributeCallExp
		t       = type[self.source]		

		// This only works because the pattern module is at the beginning... 
		// (otherwise, it returns an empty collection (QoolTransformationBase access the queue to retrieve the objects))
		helpers = atl_patterns!AttributeHelper.all_instances.select { |h| h.feature.name.eq(self.name) }
		ft = self.featureType(t, helpers)
		// I am not passing the types of the helpers... So it is important to provide accurate return types
		
		//match ft
		//case EDataType => 
		//case EClass    =>
		//end

		type[self] <- ft
	end

	// Any operation with "->"
	rule atl!CollectionOperationCallExp
		t  = type[self.source]
		arguments  = self.arguments.map { |a| x = type[a] }
		type[self] <- self.collectionOperationType(t, arguments)
	end

	rule atl!VariableExp
		self.referredVariable.varName.eq("self").if_else({
			type[self] <- type[self.up_to(atl!OclFeatureDefinition).context_.context_]			
		}, {
			self.referredVariable.varName.eq("thisModule").if_else({
				type[self] <- typ!ThisModuleType.new
			}, {
				type[self] <- type[self.referredVariable]				
			})
		})
	end
		
	// Rules
	rule atl!Binding
		t = type[self.value]
		//x = self.createBinding(type[self.value])
		//self.println(x)
		//type[self] <- self.createBinding(t)
	end
	
	// --- Primitive types ---
	
	rule atl!IntegerExp
		type[self] <- typ!IntegerType.new
	end

	rule atl!StringExp
		type[self] <- typ!StringType.new
	end

	rule atl!CollectionExp
		// Three cases:
		//   - Non empty inicialization -> types is the union of all the expressions (elements reference)
		//   - Empty inicialization within VarDcl -> type of the VarDcl (may create circular dep if done naively!)
		//   - Unknown
		self.elements.empty.if_else({
			self._refContainer.kind_of(atl!VariableDeclaration).if_else({
				type[self] <- type[self._refContainer.type]
			}, {
				t = typ!EmptyCollection.new
				t.multivalued = true
				type[self] <- t
			})
		}, {
			// TODO: Generlize computing the union of all expression elements
			// For the moment just taking the first
			representative = self.elements.first
			type[self] <- self.copyType(type[representative], true)
			// self.println(self.location)
			// type[self] <- typ!TODO_COMPUTE_UNION_OF_EXPRESSION.new			
		})
	end

	// For the moment, unknown
	rule atl!TupleExp
		tt = typ!TupleType.new
		attributes = self.tuplePart.map { |part|
			a = typ!TupleAttribute.new
			a.name = part.varName
			t = type[part] // It is a VariableDeclaration
			a.type = t
			a
		}
		// Weird syntax limitation
		tt.attributes = attributes
	
		type[self] <- tt
	end
	
	rule atl!TupleType
		tt = typ!TupleType.new
		attributes = self.attributes.map { |atl_att|
			a = typ!TupleAttribute.new
			a.name = atl_att.name
			t = type[atl_att.type]
			a.type = t
			a
		}
		// Weird syntax limitation
		tt.attributes = attributes
	
		type[self] <- tt
	end

	rule atl!IntegerType
		type[self] <- typ!IntegerType.new
	end

	rule atl!StringType
		type[self] <- typ!StringType.new
	end

	rule atl!BooleanType
		type[self] <- typ!BooleanType.new
	end

	rule atl!BooleanExp
		type[self] <- typ!BooleanType.new
	end

	rule atl!CollectionType
		type[self] <- self.copyType(type[self.elementType], true)
	end
	
	rule atl!OclAnyType
		type[self] <- typ!Unknown.new
	end

end

/*
tao make(in) -> (typ)
	template createBinding(b : in!Binding, t : typ!Type)
		ann : typ!BindingAnnotation	{
			binding    = b
			sourceType = t
		}
	end
end
*/